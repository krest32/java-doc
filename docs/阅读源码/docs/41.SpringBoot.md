# SpringBoot 流程

## 概述

1. Spring 允许自定初始化器
2. Spring 允许自定义监听器
3. 但是 Spring 不允许自定义容器启动时的监听器所监听的事件
4. Spring 的核心在与利用 BeanFactory 创建 IOC 容器，实现对于程序中需要使用的Bean进行托管，具体方法在Refreash中

## 总结

Spring的生命周期可以看作是两个部分

1. BeanFactory的生命周期
2. Bean的生命周期

然后围绕这两个生命周期，产生了一些列的扩展，比如Listener，CommandRunner、lifecycle等

## 启动

~~~java
@EnableFeignClients
@EnableDiscoveryClient
@ComponentScan(basePackages = {"com.krest"})
@SpringBootApplication(exclude={DataSourceAutoConfiguration.class})
@RibbonClient(name = "service02-mybatis-plus", configuration= MySelfRule.class)
@EnableAspectJAutoProxy     // 开启Aop功能
public class Service06_cloud {
    public static void main(String[] args) {
        // 使用Spring框架入口
        SpringApplication.run(Service06_cloud.class,args);
    }
}
~~~

## 创建SpringApplication对象

~~~java
// 启动 springboot 项目
public static ConfigurableApplicationContext run(Class<?> primarySource, String... args) {
    return run(new Class<?>[] { primarySource }, args);
}

// 实际调用，返回的是一个 ConfigurationApplicationContext
public static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {
    return new SpringApplication(primarySources).run(args);
}


// 加载资源
public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
    this.resourceLoader = resourceLoader;
    Assert.notNull(primarySources, "PrimarySources must not be null");
    this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    // 获得初始化器
    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
    // 设置监听器
    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
    this.mainApplicationClass = deduceMainApplicationClass();
}


~~~

### ConfigurationApplicationContext

类继承关系

![image-20240211181619975](img/image-20240211181619975.png)

主要实现了多个重要的接口，比如：ApplicationContext，Lifecycle

~~~java
public interface ConfigurableApplicationContext extends ApplicationContext, Lifecycle, Closeable {
    
}
~~~

### 主要属性

~~~java
// 答应标志
private Banner banner;
// 资源加载器
private ResourceLoader resourceLoader;
// 环境配置信息
private ConfigurableEnvironment environment;
// 启动类型
private WebApplicationType webApplicationType;
// 初始化器
private List<ApplicationContextInitializer<?>> initializers;
// 监听器
private List<ApplicationListener<?>> listeners;
// 是否开启懒加载
private boolean lazyInitialization = false;
~~~

#### WebApplicationType

```java
public enum WebApplicationType {
   NONE,
   SERVLET,
   REACTIVE;
```

#### ConfigurableEnvironment

~~~java
public interface ConfigurableEnvironment extends Environment, ConfigurablePropertyResolver{}
~~~



### 获取启动类型

1. 获取启动类型
2. 默认是SERVLET类型

~~~java
static WebApplicationType deduceFromClasspath() {
   
    if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) && !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)
        && !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) {
        return WebApplicationType.REACTIVE;
    }
    for (String className : SERVLET_INDICATOR_CLASSES) {
        if (!ClassUtils.isPresent(className, null)) {
            return WebApplicationType.NONE;
        }
    }
    return WebApplicationType.SERVLET;
}

~~~



### 获取初始化器

#### 主要代码

~~~java
// 通过 Spring 自定义 SPI 的方式加载用户可能自定义的初始化器
setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
~~~

#### 配置文件

~~~bash
# Application Context Initializers
org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\
org.springframework.boot.context.ContextIdApplicationContextInitializer,\
org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\
org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\
org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer
~~~



### 获取监听器

#### 主要代码

~~~java
// 通过 Spring 自定义 SPI 的方式加载用户可能自定义的监听器
setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
~~~

#### 配置文件

~~~properties
org.springframework.context.ApplicationListener=\
org.springframework.boot.ClearCachesApplicationListener,\
org.springframework.boot.builder.ParentContextCloserApplicationListener,\
org.springframework.boot.context.FileEncodingApplicationListener,\
org.springframework.boot.context.config.AnsiOutputApplicationListener,\
org.springframework.boot.context.config.ConfigFileApplicationListener,\
org.springframework.boot.context.config.DelegatingApplicationListener,\
org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\
org.springframework.boot.context.logging.LoggingApplicationListener,\
org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener
~~~



## SpringBoot.run()

### 主要流程

其实从这里可以感觉SpringBoot的项目启动实际上就是完成对ConfigurationContext的加载过程，也就是Spring的上下文。

~~~java
public ConfigurableApplicationContext run(String... args) {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    // 上下文配置
    ConfigurableApplicationContext context = null;
   // 初始化异常报告类
    Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();
    configureHeadlessProperty();
    // 监听器启动事件
    SpringApplicationRunListeners listeners = getRunListeners(args);
    listeners.starting();
    try {
       	// 封转启动参数
        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
        // 准备环境启动
        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);
        // 配置BeanInfo的忽略 ：“spring.beaninfo.ignore”，值为“true”表示跳过对BeanInfo类的搜索
        configureIgnoreBeanInfo(environment);
        // 打印Banner
        Banner printedBanner = printBanner(environment);
        // 创建上下文
        context = createApplicationContext();
        // 获取异常类的监听器
        exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,
                                                         new Class[] { ConfigurableApplicationContext.class }, context);
        // 准备上下文
        prepareContext(context, environment, listeners, applicationArguments, printedBanner);
        // 刷新上下文
        refreshContext(context);
        // 结束刷新，留待扩展功能，并未实现什么
        afterRefresh(context, applicationArguments);
        // 停止计时
        stopWatch.stop();
        if (this.logStartupInfo) {
            new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
        }
        // 监听器启动事件
        listeners.started(context);
        // 调用 ApplicationRunner 和 CommandLineRunner 对应的方法
        callRunners(context, applicationArguments);
    }
    catch (Throwable ex) {
        handleRunFailure(context, ex, exceptionReporters, listeners);
        throw new IllegalStateException(ex);
    }

    try {
        listeners.running(context);
    }
    catch (Throwable ex) {
        handleRunFailure(context, ex, exceptionReporters, null);
        throw new IllegalStateException(ex);
    }
    // 返回上下文
    return context;
}

~~~



### 返回类型 ConfigurableApplicationContext

~~~java
// 继承自 ApplicationContext
public interface ConfigurableApplicationContext extends ApplicationContext, Lifecycle, Closeable{}
~~~

#### ApplicationContext

```java
public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,
      MessageSource, ApplicationEventPublisher, ResourcePatternResolver {}
```

##### Environment

~~~java
public interface EnvironmentCapable {
	Environment getEnvironment();
}
~~~

~~~java
public interface Environment extends PropertyResolver {
	String[] getActiveProfiles();
	String[] getDefaultProfiles();
	@Deprecated
	boolean acceptsProfiles(String... profiles);
	boolean acceptsProfiles(Profiles profiles);

}
~~~

##### ListableBeanFactory

~~~java
public interface ListableBeanFactory extends BeanFactory {
    boolean containsBeanDefinition(String var1);
    int getBeanDefinitionCount();
    String[] getBeanDefinitionNames();
    String[] getBeanNamesForType(ResolvableType var1);
    String[] getBeanNamesForType(ResolvableType var1, boolean var2, boolean var3);
    String[] getBeanNamesForType(@Nullable Class<?> var1);
    String[] getBeanNamesForType(@Nullable Class<?> var1, boolean var2, boolean var3);
    <T> Map<String, T> getBeansOfType(@Nullable Class<T> var1) throws BeansException;
    <T> Map<String, T> getBeansOfType(@Nullable Class<T> var1, boolean var2, boolean var3) throws BeansException;
    String[] getBeanNamesForAnnotation(Class<? extends Annotation> var1);
    Map<String, Object> getBeansWithAnnotation(Class<? extends Annotation> var1) throws BeansException;
    @Nullable
    <A extends Annotation> A findAnnotationOnBean(String var1, Class<A> var2) throws NoSuchBeanDefinitionException;
}
~~~

##### HierarchicalBeanFactory

~~~java
public interface HierarchicalBeanFactory extends BeanFactory {
    @Nullable
    BeanFactory getParentBeanFactory();
    boolean containsLocalBean(String var1);
}
~~~

##### MessageSource

~~~java
public interface MessageSource {
	@Nullable
	String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale);
	String getMessage(String code, @Nullable Object[] args, Locale locale) throws NoSuchMessageException;
	String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException;
}

~~~

##### ApplicationEventPublisher

~~~java
@FunctionalInterface
public interface ApplicationEventPublisher {
	default void publishEvent(ApplicationEvent event) {
		publishEvent((Object) event);
    }
	void publishEvent(Object event);
}

~~~

##### ResourcePatternResolver

```
public interface ResourcePatternResolver extends ResourceLoader {
   String CLASSPATH_ALL_URL_PREFIX = "classpath*:";
   Resource[] getResources(String locationPattern) throws IOException;

}
```





###  StopWatch- 开始计时

#### start

~~~java
// 开始计时
public void start(String taskName) throws IllegalStateException {
    if (this.currentTaskName != null) {
        throw new IllegalStateException("Can't start StopWatch: it's already running");
    }
    this.currentTaskName = taskName;
    this.startTimeNanos = System.nanoTime();
}
~~~



#### stop

~~~java
// 记录停止时间，也就是整个任务启动花费了多少时间
public void stop() throws IllegalStateException {
    if (this.currentTaskName == null) {
        throw new IllegalStateException("Can't stop StopWatch: it's not running");
    }
    long lastTime = System.nanoTime() - this.startTimeNanos;
    this.totalTimeNanos += lastTime;
    this.lastTaskInfo = new TaskInfo(this.currentTaskName, lastTime);
    if (this.keepTaskList) {
        this.taskList.add(this.lastTaskInfo);
    }
    ++this.taskCount;
    this.currentTaskName = null;
}
~~~



 ### SpringBootExceptionReporter-异常播报

#### 类结构

~~~java
// 记录失败的内容
public class FailureAnalysis {
	private final String description;
	private final String action;
	private final Throwable cause;
}
~~~

#### 从配置文件中加载错误的报告类

~~~java
private boolean report(FailureAnalysis analysis, ClassLoader classLoader) {
    List<FailureAnalysisReporter> reporters = SpringFactoriesLoader.loadFactories(FailureAnalysisReporter.class,
                                                                                  classLoader);
    if (analysis == null || reporters.isEmpty()) {
        return false;
    }
    // 如果存在异常就打印异常
    for (FailureAnalysisReporter reporter : reporters) {
        reporter.report(analysis);
    }
    return true;
}
~~~

~~~bash
# FailureAnalysisReporters
org.springframework.boot.diagnostics.FailureAnalysisReporter=\
org.springframework.boot.diagnostics.LoggingFailureAnalysisReporter
~~~

#### 打印异常

通过日志打印异常

~~~java
@Override
public void report(FailureAnalysis failureAnalysis) {
    if (logger.isDebugEnabled()) {
        logger.debug("Application failed to start due to an exception", failureAnalysis.getCause());
    }
    if (logger.isErrorEnabled()) {
        logger.error(buildMessage(failureAnalysis));
    }
}
~~~



#### Catch中handle异常

~~~java
private void handleRunFailure(ConfigurableApplicationContext context, Throwable exception,
                              Collection<SpringBootExceptionReporter> exceptionReporters, SpringApplicationRunListeners listeners) {
    try {
        try {
            handleExitCode(context, exception);
            if (listeners != null) {
                listeners.failed(context, exception);
            }
        }
        finally {
            reportFailure(exceptionReporters, exception);
            if (context != null) {
                context.close();
            }
        }
    }
    catch (Exception ex) {
        logger.warn("Unable to close ApplicationContext", ex);
    }
    ReflectionUtils.rethrowRuntimeException(exception);
}

~~~



#### 集体打印异常

~~~java
private void reportFailure(Collection<SpringBootExceptionReporter> exceptionReporters, Throwable failure) {
    try {
        for (SpringBootExceptionReporter reporter : exceptionReporters) {
            if (reporter.reportException(failure)) {
                registerLoggedException(failure);
                return;
            }
        }
    }
    catch (Throwable ex) {
        // Continue with normal handling of the original failure
    }
    if (logger.isErrorEnabled()) {
        logger.error("Application run failed", failure);
        registerLoggedException(failure);
    }
}

~~~





### Listeners.Start

#### 监听器启动

~~~java

void starting() {
    for (SpringApplicationRunListener listener : this.listeners) {
        listener.starting();
    }
}
~~~



#### 广播事件

添加监听器到广播器，然后广播时间

~~~java

public EventPublishingRunListener(SpringApplication application, String[] args) {
    this.application = application;
    this.args = args;
    this.initialMulticaster = new SimpleApplicationEventMulticaster();
    for (ApplicationListener<?> listener : application.getListeners()) {
        this.initialMulticaster.addApplicationListener(listener);
    }
}

// SimpleApplicationEventMulticaster 发布应用启动事件
public void starting() {
    this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args));
}



// 开始广播
@Override
public void multicastEvent(ApplicationEvent event) {
    multicastEvent(event, resolveDefaultEventType(event));
}



// 广播
@Override
public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {
    ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
    Executor executor = getTaskExecutor();
    for (ApplicationListener<?> listener : getApplicationListeners(event, type)) {
        if (executor != null) {
            executor.execute(() -> invokeListener(listener, event));
        }
        else {
            invokeListener(listener, event);
        }
    }
}

//调用监听器发布事件
protected void invokeListener(ApplicationListener<?> listener, ApplicationEvent event) {
    ErrorHandler errorHandler = getErrorHandler();
    if (errorHandler != null) {
        try {
            doInvokeListener(listener, event);
        }
        catch (Throwable err) {
            errorHandler.handleError(err);
        }
    }
    else {
        doInvokeListener(listener, event);
    }
}



~~~



#### 依次通过监听器发布事件

~~~java
@SuppressWarnings({"rawtypes", "unchecked"})
private void doInvokeListener(ApplicationListener listener, ApplicationEvent event) {
    try {
        // 各个监听器会调用这个方法对事件进行发布
        listener.onApplicationEvent(event);
    }
    catch (ClassCastException ex) {
        String msg = ex.getMessage();
        if (msg == null || matchesClassCastMessage(msg, event.getClass())) {
            // Possibly a lambda-defined listener which we could not resolve the generic event type for
            // -> let's suppress the exception and just log a debug message.
            Log logger = LogFactory.getLog(getClass());
            if (logger.isTraceEnabled()) {
                logger.trace("Non-matching event type for listener: " + listener, ex);
            }
        }
        else {
            throw ex;
        }
    }
}
~~~







### 准备环境配置信息

prepareEnvironment

#### 主要作用

1. 确认运行环境
2. 获取环境变量
3. 加载配置文件

#### 准备程序运行的环境

~~~java
private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,
                                                   ApplicationArguments applicationArguments) {
    // Create and configure the environment
    // 确认启动的环境为Serverlet
    ConfigurableEnvironment environment = getOrCreateEnvironment();
    // 将入参配置到环境配置中
    configureEnvironment(environment, applicationArguments.getSourceArgs());
    ConfigurationPropertySources.attach(environment);
    // 监听器发布环境准备事件
    listeners.environmentPrepared(environment);
    
    bindToSpringApplication(environment);
    if (!this.isCustomEnvironment) {
        environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,
                                                                                               deduceEnvironmentClass());
    }
    ConfigurationPropertySources.attach(environment);
    return environment;
}

~~~

#### 确定程序运行环境

~~~java
private ConfigurableEnvironment getOrCreateEnvironment() {
    if (this.environment != null) {
        return this.environment;
    }
    switch (this.webApplicationType) {
        // 默认为 ServerLet 运行环境
        case SERVLET:
            return new StandardServletEnvironment();
        case REACTIVE:
            return new StandardReactiveWebEnvironment();
        default:
            return new StandardEnvironment();
    }
}
~~~

#### 配置程序运行环境 

#### ConfigurableEnvironment

![image-20220517142416592](img/image-20220517142416592.png)

##### StandardServletEnvironment

###### 继承与实现关系

我们先看看StandardServletEnvironment的继承关系，最上面是从AbstractEnvironment继承来的：

![img](img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTA0OTU0NTQ1MA==,size_16,color_FFFFFF,t_70.png)





#### 监听器广播环境准备事件-加载配置文件

在 listeners.environmentPrepared(environment); 时会发送环境准备事件，环境准备事件要通知七个监听器如下图。对于 Springboot 的配置文件application.yml或者application.properties文件的加载实际上是通过发布环境准备事件完成

ConfigFileApplicationListener #onApplicationEvent然后配置文件进行处理

~~~java

private static final String DEFAULT_SEARCH_LOCATIONS = "classpath:/,classpath:/config/,file:./,file:./config/";
private static final String DEFAULT_NAMES = "application";


public void onApplicationEvent(ApplicationEvent event) {
    if (event instanceof ApplicationEnvironmentPreparedEvent) {
        this.onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent)event);
    }

    if (event instanceof ApplicationPreparedEvent) {
        this.onApplicationPreparedEvent(event);
    }
}
~~~





### 打印Banner

#### 入口

~~~java
private Banner printBanner(ConfigurableEnvironment environment) {
    // 判断是否打印Banner
    if (this.bannerMode == Banner.Mode.OFF) {
        return null;
    }
    // 选择资源加载器
    ResourceLoader resourceLoader = (this.resourceLoader != null) ? this.resourceLoader
        : new DefaultResourceLoader(getClassLoader());
    // 创建spring Banner对象
    SpringApplicationBannerPrinter bannerPrinter = new SpringApplicationBannerPrinter(resourceLoader, this.banner);
    
    if (this.bannerMode == Mode.LOG) {
        return bannerPrinter.print(environment, this.mainApplicationClass, logger);
    }
    // 执行打印
    return bannerPrinter.print(environment, this.mainApplicationClass, System.out);
}
~~~

 #### 打印 Banner

~~~java
Banner print(Environment environment, Class<?> sourceClass, Log logger) {
    // 获取banner
    Banner banner = getBanner(environment);
    try {
        // 使用日志的方式创建String
        logger.info(createStringFromBanner(banner, environment, sourceClass));
    }
    catch (UnsupportedEncodingException ex) {
        logger.warn("Failed to create String for banner", ex);
    }
 	// 放回需要打印的 banner 对象   
    return new PrintedBanner(banner, sourceClass);
}
~~~

#### 获取 Banner

~~~~java
// 默认的banner
private static final Banner DEFAULT_BANNER = new SpringBootBanner();

private Banner getBanner(Environment environment) {
    Banners banners = new Banners();
    // 图片banner
    banners.addIfNotNull(getImageBanner(environment));
    // 文字bannner
    banners.addIfNotNull(getTextBanner(environment));
    // 如果有不止一个banner，那么就返回 Banner 对象
    if (banners.hasAtLeastOneBanner()) {
        return banners;
    }
    if (this.fallbackBanner != null) {
        return this.fallbackBanner;
    }
	// 如果没有指定的Banner，那么就返回默认的banner 
    return DEFAULT_BANNER;
}
~~~~

#### 默认 Banner

~~~java
class SpringBootBanner implements Banner {

	private static final String[] BANNER = { "", "  .   ____          _            __ _ _",
			" /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\", "( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\",
			" \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )", "  '  |____| .__|_| |_|_| |_\\__, | / / / /",
			" =========|_|==============|___/=/_/_/_/" };

	private static final String SPRING_BOOT = " :: Spring Boot :: ";

	private static final int STRAP_LINE_SIZE = 42;

}
~~~





### 创建上下文环境

+ 很明显，因为我们知道 webApplicationType 值是 servlet，所以这里创建的是`AnnotationConfigServletWebServerApplicationContext` 类型的上下文
+ 这里需要注意：AnnotationConfigServletWebServerApplicationContext 构造函数中会创建 AnnotatedBeanDefinitionReader。而在 AnnotatedBeanDefinitionReader 构造函数中会调用 AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);，该方法将一些必要Bean(如ConfigurationClassPostProcessor、AutowiredAnnotationBeanPostProcessor、CommonAnnotationBeanPostProcessor 等)注入到了容器中。

#### createApplicationContext

~~~java
public static final String DEFAULT_SERVLET_WEB_CONTEXT_CLASS = "org.springframework.boot."
			+ "web.servlet.context.AnnotationConfigServletWebServerApplicationContext";

context = createApplicationContext();


protected ConfigurableApplicationContext createApplicationContext() {
    Class<?> contextClass = this.applicationContextClass;
    if (contextClass == null) {
        try {
            switch (this.webApplicationType) {
                case SERVLET:
                    contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);
                    break;
                case REACTIVE:
                    contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);
                    break;
                default:
                    contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);
            }
        }
        catch (ClassNotFoundException ex) {
            throw new IllegalStateException(
                "Unable create a default ApplicationContext, please specify an ApplicationContextClass", ex);
        }
    }
    return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);
}
~~~



AnnotationConfigServletWebServerApplicationContext 构造函数

~~~java
public class AnnotationConfigServletWebServerApplicationContext extends ServletWebServerApplicationContext
		implements AnnotationConfigRegistry {
    
    private final AnnotatedBeanDefinitionReader reader;
	private final ClassPathBeanDefinitionScanner scanner;
    
    public AnnotationConfigServletWebServerApplicationContext() {
		this.reader = new AnnotatedBeanDefinitionReader(this);
		this.scanner = new ClassPathBeanDefinitionScanner(this);
	}
}
~~~



### 准备上下文环境

#### 概述

1. 这一步已经存在了工厂Bean

#### prepareContext

~~~java
prepareContext(context, environment, listeners, applicationArguments, printedBanner);

private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment,
                            SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) {
    // 设置运行环境
    context.setEnvironment(environment);
    // 执行容器后置处理 ： 可以注册beanName策略生成器、设置资源加载器，设置转换服务等。
    // 但这里默认是没有做任何处理。目的是留给后续可以扩展
    postProcessApplicationContext(context);
    // 执行初始化的方法
    applyInitializers(context);
    // 监听器打印上下文准备信息
    listeners.contextPrepared(context);
    if (this.logStartupInfo) {
        logStartupInfo(context.getParent() == null);
        logStartupProfileInfo(context);
    }
    // 获取bean工厂
    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
    // 注册 springApplicationArguments等一系列bean
    beanFactory.registerSingleton("springApplicationArguments", applicationArguments);
    if (printedBanner != null) {
        // 找到 Banner Bean
        beanFactory.registerSingleton("springBootBanner", printedBanner);
    }
    // 判断是否可以属性覆盖
    if (beanFactory instanceof DefaultListableBeanFactory) {
        ((DefaultListableBeanFactory) beanFactory)
        .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);
    }
    // 判断是否是懒加载
    if (this.lazyInitialization) {
        context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());
    }
    // 这里加载的实际上是启动类
    Set<Object> sources = getAllSources();
    Assert.notEmpty(sources, "Sources must not be empty");
    // 这里将启动类加入到 beanDefinitionMap 中，为后续的自动化配置做好了基础
    load(context, sources.toArray(new Object[0]));
    // 监听器发布 上下文准备完成事件
    listeners.contextLoaded(context);
}

~~~

#### 获取BeanFactory

1. BeanFactory 就是一个Map集合，存储了许多的Class对象

~~~java
public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {
    @Nullable
    private static Class<?> javaxInjectProviderClass;
    private static final Map<String, Reference<DefaultListableBeanFactory>> serializableFactories;
    @Nullable
    private String serializationId;
    private boolean allowBeanDefinitionOverriding = true;
    private boolean allowEagerClassLoading = true;
    @Nullable
    private Comparator<Object> dependencyComparator;
    private AutowireCandidateResolver autowireCandidateResolver = new SimpleAutowireCandidateResolver();
    private final Map<Class<?>, Object> resolvableDependencies = new ConcurrentHashMap(16);
    // 存放Bean信息的Map
    private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap(256);
    private final Map<Class<?>, String[]> allBeanNamesByType = new ConcurrentHashMap(64);
    private final Map<Class<?>, String[]> singletonBeanNamesByType = new ConcurrentHashMap(64);
    private volatile List<String> beanDefinitionNames = new ArrayList(256);
    private volatile Set<String> manualSingletonNames = new LinkedHashSet(16);
    @Nullable
    private volatile String[] frozenBeanDefinitionNames;
    private volatile boolean configurationFrozen = false;
}
~~~



#### Load(重要)->注册工厂单例bean 

~~~java
protected void load(ApplicationContext context, Object[] sources) {
    if (logger.isDebugEnabled()) {
        logger.debug("Loading source " + StringUtils.arrayToCommaDelimitedString(sources));
    }
    BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);
    if (this.beanNameGenerator != null) {
        loader.setBeanNameGenerator(this.beanNameGenerator);
    }
    if (this.resourceLoader != null) {
        loader.setResourceLoader(this.resourceLoader);
    }
    if (this.environment != null) {
        loader.setEnvironment(this.environment);
    }
    loader.load();
}

// 实际执行
int load() {
    int count = 0;
    for (Object source : this.sources) {
        count += load(source);
    }
    return count;
}

// 加载所有的资源
private int load(Object source) {
    Assert.notNull(source, "Source must not be null");
    if (source instanceof Class<?>) {
        return load((Class<?>) source);
    }
    if (source instanceof Resource) {
        return load((Resource) source);
    }
    if (source instanceof Package) {
        return load((Package) source);
    }
    if (source instanceof CharSequence) {
        return load((CharSequence) source);
    }
    throw new IllegalArgumentException("Invalid source type " + source.getClass());
}
~~~



#### load Class

注册启动类BeanClass

~~~java
private int load(Class<?> source) {
    // 判断是否存在 groovy 加载方式
    if (isGroovyPresent() && GroovyBeanDefinitionSource.class.isAssignableFrom(source)) {
        GroovyBeanDefinitionSource loader = BeanUtils.instantiateClass(source, GroovyBeanDefinitionSource.class);
        load(loader);
    }

    // 判断是否是Component Class
    if (isComponent(source)) {
        this.annotatedReader.register(source);
        return 1;
    }
    return 0;
}

// 注册 Component Bean
private boolean isComponent(Class<?> type) {
    if (MergedAnnotations.from(type, SearchStrategy.TYPE_HIERARCHY).isPresent(Component.class)) {
        return true;
    }
    return !type.getName().matches(".*\\$_.*closure.*") && !type.isAnonymousClass()
        && type.getConstructors() != null && type.getConstructors().length != 0;
}

// 注册 组件bean
public void register(Class<?>... componentClasses) {
    for (Class<?> componentClass : componentClasses) {
        registerBean(componentClass);
    }
}

// 注册 bean
public void registerBean(Class<?> beanClass) {
    doRegisterBean(beanClass, null, null, null, null);
}

// 这里的 beanClass 其实就是启动类的 beanClass 
private <T> void doRegisterBean(Class<T> beanClass, @Nullable String name,
                                @Nullable Class<? extends Annotation>[] qualifiers, @Nullable Supplier<T> supplier,
                                @Nullable BeanDefinitionCustomizer[] customizers) {

    AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);
    if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
        return;
    }

    abd.setInstanceSupplier(supplier);
    ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
    // 设置作用域
    abd.setScope(scopeMetadata.getScopeName());
    String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));

    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
    // 判断相关属性
    if (qualifiers != null) {
        for (Class<? extends Annotation> qualifier : qualifiers) {
            if (Primary.class == qualifier) {
                abd.setPrimary(true);
            }
            else if (Lazy.class == qualifier) {
                abd.setLazyInit(true);
            }
            else {
                abd.addQualifier(new AutowireCandidateQualifier(qualifier));
            }
        }
    }
    if (customizers != null) {
        for (BeanDefinitionCustomizer customizer : customizers) {
            customizer.customize(abd);
        }
    }

    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
}


public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException {
    String beanName = definitionHolder.getBeanName();
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
    String[] aliases = definitionHolder.getAliases();
    if (aliases != null) {
        String[] var4 = aliases;
        int var5 = aliases.length;

        for(int var6 = 0; var6 < var5; ++var6) {
            String alias = var4[var6];
            registry.registerAlias(beanName, alias);
        }
    }
}

~~~

#### 监听器执行

最终执行的是监听器的 onApplicationEvent 方法



### refresh()-刷新上下文环境

#### 概述

**Spring模块完成内容**

1. **prepareRefresh** ： 初始化前的准备工作，例如对系统属性或者环境变量进行准备及验证。在某些情况下项目的使用需要读取某些系统变量，那么在启动时候，就可以通过准备函数来进行参数的校验。

2. **obtainFreshBeanFactory** ：初始化BeanFactory，并进行XML文件读取（如果需要的话）。 这一步之后ApplicationContext就具有BeanFactory 所提供的功能，也就是可以进行Bean的提取等基础操作了。

3. **prepareBeanFactory** ：对BeanFactory进行各种功能填充。

4. **postProcessBeanFactory**：对BeanFactory做额外处理。默认没有实现

5. **invokeBeanFactoryPostProcessors** ：激活各种BeanFactory处理器(调用了各种BeanFactoryPostProcessor)。其中最为关键的是 ConfigurationClassPostProcessor ，在这里完成了配置类的解析，生成的注入容器中的bean的BeanDefinition。后续会根据BeanDefinition生成各种单例bean

6. **registerBeanPostProcessors** ：从Beanfactory种，获取beanostProcessors处理器，然后进行一些使用之前的初始化，比如处理器的排序等。

7. **initMessageSource** ：为上下文初始化Message源，即对不同语言的消息体进行国际化处理

8. **initApplicationEventMulticaster** ：初始化应用消息广播器，并放入"applicationEventMulticaster" bean 中

9. **onRefresh** ：留给子类来初始化其他bean

10. **registerListeners** ：在所有注册的bean中查找listener bean，注册到消息广播器中

11. **finishBeanFactoryInitialization** ：初始化剩下的实例(非惰性)，在这里调用了getBean方法，创建了非惰性的bean实例

12. **finishRefresh** ：完成刷新过程，通知生命周期处理器 lifecycleProcesseor 刷新过程，同时发出ContextRefreshEvent 通知别人。

**这里需要注意的两个方法：**

+ initPropertySources() ：这个方法是为了给用户自己实现初始化逻辑，可以初始化一些属性资源。因此Spring并没有实现这个方法。
+ validateRequiredProperties() ：这个方法是对一些启动必须的属性的验证。我们可以通过实现或者继承 ApplicationContext 来重写这两个方法，从而完成一些基本属性的校验。

#### refreshContext

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        prepareRefresh();
        // 完成了BeanFactory的创建
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
        prepareBeanFactory(beanFactory);
        try {
            // BeanFactory 后置处理器
            postProcessBeanFactory(beanFactory);
            // 注册 BeanFactory 后置处理器
            invokeBeanFactoryPostProcessors(beanFactory);
            // Register bean processors that intercept bean creation.
            registerBeanPostProcessors(beanFactory);
            // 初始化消息机制
            initMessageSource();
            // 初始化广播事件
            initApplicationEventMulticaster();
            // 刷新上下文Bean
            onRefresh();
            // 检查监听器
            registerListeners();
            // 完成BeanFactory初始化
            finishBeanFactoryInitialization(beanFactory);
            // 发布完成刷新事件
            finishRefresh();
        }
        catch (BeansException ex) {
			...
        }

        finally {
			// 重置
            resetCommonCaches();
        }
    }
}

```

#### obtainFreshBeanFactory

从字面意思就是获取BeanFactory。经过这个方法，BeanFactory 就已经被创建完成。

~~~java
// Tell the subclass to refresh the internal bean factory.
ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
    refreshBeanFactory();
    return getBeanFactory();
}

// BeanFactory 对象
public class DefaultListableBeanFactory 
    extends AbstractAutowireCapableBeanFactory
    implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable {

    private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap(256);
    private final Map<Class<?>, String[]> allBeanNamesByType = new ConcurrentHashMap(64);
    private final Map<Class<?>, String[]> singletonBeanNamesByType = new ConcurrentHashMap(64);
    private volatile List<String> beanDefinitionNames = new ArrayList(256);
    private volatile Set<String> manualSingletonNames = new LinkedHashSet(16);
    
    
    protected final void refreshBeanFactory() throws IllegalStateException {
        if (!this.refreshed.compareAndSet(false, true)) {
            throw new IllegalStateException(
                "GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once");
        }
        this.beanFactory.setSerializationId(getId());
    }
    
	public final ConfigurableListableBeanFactory getBeanFactory() {
		return this.beanFactory;
	}
    
    public String getId() {
		return this.id;
	}

}
~~~

#### prepareBeanFactory

`prepareBeanFactory()` 对`beanFactry` 做了一些准备工作，设置了一些属性来扩展功能。

1. 为BeanFactory增添一些配置信息
   1. 增加 SpEL 语言的支持
   2. 增加对属性编辑器的支持
   3. 增加对一些内置类，比如 EnvironmentAware、EmbeddedValueResolverAware等。
   4. 设置了依赖功能可忽略的接口
   5. 注册一些固定依赖的属性
   6. 增加 AspectJ 的支持
   7. 将相关环境变量及属性注册以单例模式注册

~~~java
protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
    // 设置当前beanFactory 的classLoader 为当前context 的classLoader
    beanFactory.setBeanClassLoader(getClassLoader());
    // 设置beanFactory 的表达式语言处理器，Spring3 增加了表达式语言的支持
    // 默认可以使用 #{bean.xxx}的形式来调用处理相关属性。
    beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
    // 为beanFactory 增加一个默认的propertyEditor，这个主要是针对bean的属性等设置管理的一个工具
    beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

    // 添加BeanPostProcessor
    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
    // 设置了几个忽略自动装配的接口
    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

    // 设置了几个自动装配的特殊规则
    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
    beanFactory.registerResolvableDependency(ResourceLoader.class, this);
    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
    beanFactory.registerResolvableDependency(ApplicationContext.class, this);

    // Register early post-processor for detecting inner beans as ApplicationListeners.
    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

    // 增加对 AspectJ的支持
    if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
        // Set a temporary ClassLoader for type matching.
        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    }

    // 添加默认的系统环境bean
    if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
    }
    if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
    }
    if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
    }
}
~~~



#### initMessageSource

~~~java
protected void initMessageSource() {
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {
        this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);
        // Make MessageSource aware of parent MessageSource.
        if (this.parent != null && this.messageSource instanceof HierarchicalMessageSource) {
            HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;
            if (hms.getParentMessageSource() == null) {
                // Only set parent context as parent MessageSource if no parent MessageSource
                // registered already.
                hms.setParentMessageSource(getInternalParentMessageSource());
            }
        }
        if (logger.isTraceEnabled()) {
            logger.trace("Using MessageSource [" + this.messageSource + "]");
        }
    }
    else {
        // Use empty MessageSource to be able to accept getMessage calls.
        DelegatingMessageSource dms = new DelegatingMessageSource();
        dms.setParentMessageSource(getInternalParentMessageSource());
        this.messageSource = dms;
        beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);
        if (logger.isTraceEnabled()) {
            logger.trace("No '" + MESSAGE_SOURCE_BEAN_NAME + "' bean, using [" + this.messageSource + "]");
        }
    }
}

~~~

#### postProcessBeanFactory

1. 没有默认实现

~~~~java
protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
}
~~~~



#### invokeBeanFactoryPostProcessors

1. BeanFactory 作为Spring中容器功能的基础，用于存放所有已经加载的bean，为了保证程序的可扩展性，Spring针对BeanFactory 做了大量的扩展，如PostProcessor。
2. 和BeanPostProcessor原理一致，Spring提供了对BeanFactory进行操作的处理器BeanFactoryProcessor，简单来说就是获取容器BeanFactory，这样就可以在真正初始化bean之前对bean做一些处理操作。
3. 这一步的功能主要是激活各种 BeanFactoryPostProcessors。
4. 注册绝大大多数的BeanDefinition就是在这一步的其中一个 BeanFactoryPostProceseor中完成的

```java
// Invoke factory processors registered as beans in the context.
invokeBeanFactoryPostProcessors(beanFactory);
```


#### registerBeanPostProcessors(beanFactory);

+ `registerBeanPostProcessors` 将 BeanPostProcessor 初始化后并将其 保存到了AbstractBeanFactory#beanPostProcessors，方便之后对 BeanPostProcessor 的调用。
+ 相较于invokeBeanFactoryPostProcessors 方法，这里并没有考虑打硬编码的后处理器的顺序问题。其原因在于invokeBeanFactoryPostProcessors中不仅要实现BeanFactoryPostProcessor的注册功能，还需要完成激活（执行对应方法）操作，所以需要载入配置中的定义并进行激活。而对于BeanPostProcessor 并不需要马上调用，并且硬编码方式实现的功能是将后处理器提取并调用，这里了并不需要调用，所以不需要考虑硬编码问题。这里只需要将配置文件中的BeanPostProcessor 创建之后出来并注册进行BeanFactory中即可。需要注意：这里虽然没有调用 BeanPostProcessor，但是 BeanPostProcessor 的实例已经通过 beanFactory.getBean 创建完成。

下面来看看代码：

~~~java
public static void registerBeanPostProcessors(
    ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {
    // 获取所有后处理器的name
    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

    int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
    //可能会有些情况当Spring 的配置中的后处理器还没有被注册就已经开始了bean的实例化，便会打印出BeanPostProcessorChecker 中设定的信息
    beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

    // 保存实现了PriorityOrderd 接口的 后处理器
    List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
    // 保存MergedBeanDefinitionPostProcessor 后处理器
    List<BeanPostProcessor> internalPostProcessors = new ArrayList<>();	
    // 保存实现了Orderd 接口的 后处理器
    List<String> orderedPostProcessorNames = new ArrayList<>();
    // 保存没有实现任何排序接口的后处理器
    List<String> nonOrderedPostProcessorNames = new ArrayList<>();
    // 按照规则筛选出不同的后处理器保存到集合中
    for (String ppName : postProcessorNames) {
        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {

            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            priorityOrderedPostProcessors.add(pp);
            if (pp instanceof MergedBeanDefinitionPostProcessor) {
                internalPostProcessors.add(pp);
            }
        }
        else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
            orderedPostProcessorNames.add(ppName);
        }
        else {
            nonOrderedPostProcessorNames.add(ppName);
        }
    }

    // 对实现了PriorityOrderd 接口的 后处理器 进行排序
    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
    // 注册，实际上就是保存到 AbstractBeanFactory#beanPostProcessors 集合中。在getBean使用的时候直接拿取该属性即可
    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

    // 下面逻辑类似
    List<BeanPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());
    for (String ppName : orderedPostProcessorNames) {
        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
        orderedPostProcessors.add(pp);
        if (pp instanceof MergedBeanDefinitionPostProcessor) {
            internalPostProcessors.add(pp);
        }
    }
    sortPostProcessors(orderedPostProcessors, beanFactory);
    registerBeanPostProcessors(beanFactory, orderedPostProcessors);

    // Now, register all regular BeanPostProcessors.
    List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());
    for (String ppName : nonOrderedPostProcessorNames) {
        // 创建了 BeanPostProcessor 实例
        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
        nonOrderedPostProcessors.add(pp);
        if (pp instanceof MergedBeanDefinitionPostProcessor) {
            internalPostProcessors.add(pp);
        }
    }
    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

    // Finally, re-register all internal BeanPostProcessors.
    sortPostProcessors(internalPostProcessors, beanFactory);
    // 这里并不是重复注册， registerBeanPostProcessors 方法会先移除已存在的 BeanPostProcessor 随后重新加入。
    registerBeanPostProcessors(beanFactory, internalPostProcessors);

    // Re-register post-processor for detecting inner beans as ApplicationListeners,
    // moving it to the end of the processor chain (for picking up proxies etc).
    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
}

~~~



#### initApplicationEventMulticaster

这里的作用很明显就是提取配置中定义的MessageSource，并将其记录在Spring容器中，也就是AbstractApplicationContext中。如果用户没有设置资源文件，Spring提供了默认的配置 DelegatingMessageSource。

代码逻辑也很简单：在这里Spring 通过 beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class); 来获取名称为 MESSAGE_SOURCE_BEAN_NAME (messageSource) 的bean作为 资源文件。这里也体现出了Spring “约束大于规定”的原则。

```java
protected void initMessageSource() {
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {
        // 获取自定义资源文件。这里可以看出使用了硬编码，默认资源文件为messageSource，否则便获取不到自定义配置资源
        this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);
        // Make MessageSource aware of parent MessageSource.
        if (this.parent != null && this.messageSource instanceof HierarchicalMessageSource) {
            HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;
            if (hms.getParentMessageSource() == null) {
                // Only set parent context as parent MessageSource if no parent MessageSource
                // registered already.
                hms.setParentMessageSource(getInternalParentMessageSource());
            }
        }
        if (logger.isTraceEnabled()) {
            logger.trace("Using MessageSource [" + this.messageSource + "]");
        }
    }
    else {
        // Use empty MessageSource to be able to accept getMessage calls.
        // 如果用户没有配置，则使用默认的的资源文件
        DelegatingMessageSource dms = new DelegatingMessageSource();
        dms.setParentMessageSource(getInternalParentMessageSource());
        this.messageSource = dms;
        beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);
        if (logger.isTraceEnabled()) {
            logger.trace("No '" + MESSAGE_SOURCE_BEAN_NAME + "' bean, using [" + this.messageSource + "]");
        }
    }
}

```



#### onRefresh

1. 没有具体实现，子类自定义

~~~java
protected void onRefresh() throws BeansException {
    // For subclasses: do nothing by default.
}
~~~

2. Spring boot 启动后调用 GenericWebApplicationContext #onRefresh，看代码，貌似没做什么特殊的事情

~~~java
public class GenericWebApplicationContext extends GenericApplicationContext implements ConfigurableWebApplicationContext, ThemeSource {
    
    protected void onRefresh() {
        this.themeSource = UiApplicationContextUtils.initThemeSource(this);
    }
    
    public static ThemeSource initThemeSource(ApplicationContext context) {
        if (context.containsLocalBean(THEME_SOURCE_BEAN_NAME)) {
            ThemeSource themeSource = context.getBean(THEME_SOURCE_BEAN_NAME, ThemeSource.class);
            // Make ThemeSource aware of parent ThemeSource.
            if (context.getParent() instanceof ThemeSource && themeSource instanceof HierarchicalThemeSource) {
                HierarchicalThemeSource hts = (HierarchicalThemeSource) themeSource;
                if (hts.getParentThemeSource() == null) {
                    // Only set parent context as parent ThemeSource if no parent ThemeSource
                    // registered already.
                    hts.setParentThemeSource((ThemeSource) context.getParent());
                }
            }
            if (logger.isDebugEnabled()) {
                logger.debug("Using ThemeSource [" + themeSource + "]");
            }
            return themeSource;
        }
        else {
            // Use default ThemeSource to be able to accept getTheme calls, either
            // delegating to parent context's default or to local ResourceBundleThemeSource.
            HierarchicalThemeSource themeSource = null;
            if (context.getParent() instanceof ThemeSource) {
                themeSource = new DelegatingThemeSource();
                themeSource.setParentThemeSource((ThemeSource) context.getParent());
            }
            else {
                themeSource = new ResourceBundleThemeSource();
            }
            if (logger.isDebugEnabled()) {
                logger.debug("Unable to locate ThemeSource with name '" + THEME_SOURCE_BEAN_NAME +
                             "': using default [" + themeSource + "]");
            }
            return themeSource;
        }
    }
}
~~~



#### registerListeners

1. 注册硬编码注册的监听器
2. 注册配置注册的监听器
3. 发布早先的监听事件

~~~java
protected void registerListeners() {
    // Register statically specified listeners first.
    // 硬编码方式注册的监听器处理
    for (ApplicationListener<?> listener : getApplicationListeners()) {
        getApplicationEventMulticaster().addApplicationListener(listener);
    }

    // Do not initialize FactoryBeans here: We need to leave all regular beans
    // uninitialized to let post-processors apply to them!
    // 配置文件注册的监听处理器
    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
    for (String listenerBeanName : listenerBeanNames) {
        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
    }

    // Publish early application events now that we finally have a multicaster...
    // 发布之前保存的需要发布的事件
    Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;
    this.earlyApplicationEvents = null;
    if (earlyEventsToProcess != null) {
        for (ApplicationEvent earlyEvent : earlyEventsToProcess) {
            getApplicationEventMulticaster().multicastEvent(earlyEvent);
        }
    }
}

~~~



#### finishBeanFactoryInitialization--(重点getBean)

这一步的目的是 结束BeanFactory的初始化工作（大体上完成了所有Bean的一个初始化工作），其中包括如下几步 ：

1. 对 ConversionService 的设置。通过 ConversionService 的配置可以很轻松完成一些类型转换工作。
2. 冻结所有的bean定义 。到这一步，也就说所有的bean定义已经定型了，不可被修改了，也正式可以缓存bean的元数据了。
3. 初始化剩下的非惰性单实例。ApplicationContext 实现的默认行为就是启动时将所有单例 bean提前进行实例化。提前实例化意味着作为初始化过程的一部分，ApplicationContext 实例会创建并配置所有的单例bean。而这个实例化的过程就是在 preInstantiateSingletons 中完成的。

~~~java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    // 1. 对 ConversionService 的设置
    // 如果 BeanFactory 中加载了beanName 为 ConversionService 的bean，并且类型是 ConversionService。那么将其设置为 conversionService
    if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&
        beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
        beanFactory.setConversionService(
            // 重点方法
            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
    }
    if (!beanFactory.hasEmbeddedValueResolver()) {
        beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal));
    }
    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
    // 开始调用 getBean 方法初始化LoadTimeWeaverAware, 如果有类实现了这个接口，会被吊桶
    for (String weaverAwareName : weaverAwareNames) {
        getBean(weaverAwareName);
    }

    beanFactory.setTempClassLoader(null);

    // 2. 冻结所有的bean定义，说明注册的bean定义将不被修改或任何进一步的处理
    beanFactory.freezeConfiguration();

    // Instantiate all remaining (non-lazy-init) singletons.
    // 3. 初始化剩下的非惰性单实例- 核心
    beanFactory.preInstantiateSingletons();
}

~~~

这里我们需要特别关注一下 `DefaultListableBeanFactory#preInstantiateSingletons`，在这里面，容器创建了所有的非惰性单实例。（之所以不创建原型bean，是因为原型bean没必要进行缓存，每次使用直接









#### finishRefresh

在 Spring 中还提供了 Lifecycle 接口，Lifecycle 接口包含 start、stop 方法，实现此接口后Spring会保证在启动的时候调用其 start 方法开始生命周期，并在Spring关闭的时候调用stop方法来结束生命周期，通常用来配置后台程序，在启动后一直运行(如对MQ进行轮询等)。而ApplicationContext 的初始化最后证实保证了这一功能的实现。

~~~java
protected void finishRefresh() {
    // 清除资源缓存
    clearResourceCaches();

    // 当Application 启动或停止时，会通过 LifecycleProcessor 来与所有声明的bean周期做状态更新，
    // 而在LifecycleProcessor 的使用前首先需要初始化，这里进行了LifecycleProcessor  的初始化。
    initLifecycleProcessor();

    // 启动所有实现了Lifecycle接口的bean
    getLifecycleProcessor().onRefresh();

    // 当完成ApplicationContext 初始化的时候，要通过Spring 中的事件发布机制来发出ContextRefreshedEvent 的事件，以保证对应的监听器可以做进一步的逻辑处理。
    publishEvent(new ContextRefreshedEvent(this));

    // 注册 ApplicationContext
    LiveBeansView.registerApplicationContext(this);
}


~~~



getLifecycleProcessor().onRefresh();

~~~java
public interface LifecycleProcessor extends Lifecycle {

	void onRefresh();

	void onClose();

}
~~~









#### resetCommonCaches

~~~java
protected void resetCommonCaches() {
    ReflectionUtils.clearCache();
    AnnotationUtils.clearCache();
    ResolvableType.clearCache();
    CachedIntrospectionResults.clearClassLoader(getClassLoader());
}
~~~





### 刷新上下文之后

1. 没有具体实现，用户可以自定义

#### afterRefresh

~~~java
protected void afterRefresh(ConfigurableApplicationContext context, ApplicationArguments args) {
}

~~~





### stopWatch.stop()

1. 容器准备完成



### listeners.started

监听器再次执行环境准备事件





### callRunners

#### 入口

~~~java
callRunners(context, applicationArguments);
~~~

~~~java
private void callRunners(ApplicationContext context, ApplicationArguments args) {
    List<Object> runners = new ArrayList<>();
    runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());
    runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());
    AnnotationAwareOrderComparator.sort(runners);
    for (Object runner : new LinkedHashSet<>(runners)) {
        if (runner instanceof ApplicationRunner) {
            callRunner((ApplicationRunner) runner, args);
        }
        if (runner instanceof CommandLineRunner) {
            callRunner((CommandLineRunner) runner, args);
        }
    }
}

~~~



#### 开始运行

~~~java
private void callRunner(ApplicationRunner runner, ApplicationArguments args) {
    try {
        (runner).run(args);
    }
    catch (Exception ex) {
        throw new IllegalStateException("Failed to execute ApplicationRunner", ex);
    }
}
~~~



### listeners.running

监听器执行系统已经启动了的事件





## 监听器--各个阶段执行不同任务

### SpringApplicationRunListeners

1. 设计理念：容器生命周期、监听器模式、函数式接口

2. 通过Listener作为Spring的一个扩展点，在Spring容器的各个阶段，通过发布事件的方式，可以执行用户自定义的监听器任务

3. 不同的容器运行阶段，需要发布不同的容器事件

4. 容器的执行顺序从上到下

   

~~~java
public interface SpringApplicationRunListener {
    // 开始启动
    default void starting() {}
	// 准备环境参数
	default void environmentPrepared(ConfigurableEnvironment environment) {}
	// 上下文准备好
	default void contextPrepared(ConfigurableApplicationContext context) {}
	// 上下文加载成功
	default void contextLoaded(ConfigurableApplicationContext context) {}
    // 容器启动
	default void started(ConfigurableApplicationContext context) {}
	// 容器运行中
	default void running(ConfigurableApplicationContext context) {}
	// 容器启动失败
	default void failed(ConfigurableApplicationContext context, Throwable exception) {}
    
    /**
    *	通过函数式接口传递相应的监听器任务
    */
    private void doWithListeners(String stepName, Consumer<SpringApplicationRunListener> listenerAction,
                                 Consumer<StartupStep> stepAction) {
        StartupStep step = this.applicationStartup.start(stepName);
        this.listeners.forEach(listenerAction);
        if (stepAction != null) {
            stepAction.accept(step);
        }
        step.end();
    }
}
~~~



### 鼻祖监听器

~~~~java
@FunctionalInterface
public interface ApplicationListener<E extends ApplicationEvent> extends EventListener {
	void onApplicationEvent(E event);
}

~~~~



### Spring Boot 需要的监听器

~~~bash
org.springframework.context.ApplicationListener=\
org.springframework.boot.ClearCachesApplicationListener,\
org.springframework.boot.builder.ParentContextCloserApplicationListener,\
org.springframework.boot.context.FileEncodingApplicationListener,\
org.springframework.boot.context.config.AnsiOutputApplicationListener,\
org.springframework.boot.context.config.ConfigFileApplicationListener,\
org.springframework.boot.context.config.DelegatingApplicationListener,\
org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\
org.springframework.boot.context.logging.LoggingApplicationListener,\
org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener
~~~





### 所有监听器

#### ClearCachesApplicationListener

如果是 ContextRefreshedEvent ，才会促发这个监听器

~~~java
@Override
public void onApplicationEvent(ContextRefreshedEvent event) {
    ReflectionUtils.clearCache();
    clearClassLoaderCaches(Thread.currentThread().getContextClassLoader());
}
~~~



#### ParentContextCloserApplicationListener

默认不会被触发

~~~java
@Override
public void onApplicationEvent(ParentContextAvailableEvent event) {
    maybeInstallListenerInParent(event.getApplicationContext());
}
~~~



####  FileEncodingApplicationListener

##### 概述

如果系统文件编码和环境变量中指定的不同则终止应用启动。具体的方法是比较系统属性file.encoding和环境变量spring.mandatory-file-encoding是否相等(大小写不敏感)。

##### onApplicationEvent

~~~java
@Override
public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
    ConfigurableEnvironment environment = event.getEnvironment();
    if (!environment.containsProperty("spring.mandatory-file-encoding")) {
        return;
    }
    String encoding = System.getProperty("file.encoding");
    String desired = environment.getProperty("spring.mandatory-file-encoding");
    if (encoding != null && !desired.equalsIgnoreCase(encoding)) {
        if (logger.isErrorEnabled()) {
            logger.error("System property 'file.encoding' is currently '" + encoding + "'. It should be '" + desired
                         + "' (as defined in 'spring.mandatoryFileEncoding').");
            logger.error("Environment variable LANG is '" + System.getenv("LANG")
                         + "'. You could use a locale setting that matches encoding='" + desired + "'.");
            logger.error("Environment variable LC_ALL is '" + System.getenv("LC_ALL")
                         + "'. You could use a locale setting that matches encoding='" + desired + "'.");
        }
        throw new IllegalStateException("The Java Virtual Machine has not been configured to use the "
                                        + "desired default character encoding (" + desired + ").");
    }
}

~~~







#### AnsiOutputApplicationListener

##### 概述

+ 根据spring.output.ansi.enabled参数配置AnsiOutput
+  生成ANSI编码的输出，自动尝试检测终端是否支持ANSI。

##### onApplicationEvent

~~~java
@Override
public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
    ConfigurableEnvironment environment = event.getEnvironment();
    Binder.get(environment).bind("spring.output.ansi.enabled", AnsiOutput.Enabled.class)
        .ifBound(AnsiOutput::setEnabled);
    AnsiOutput.setConsoleAvailable(environment.getProperty("spring.output.ansi.console-available", Boolean.class));
}

~~~





#### ConfigFileApplicationListener

##### 概述

加载配置文件

~~~java
/**
 * EnvironmentPostProcessor通过从众所周知的位置加载属性来配置上下文。默认情况下这些属性会被从以下这些目录下的`application.properties`和/或`application.yml`加载：

 - file:./config/
 - file:./
 - classpath:config/ 
 - classpath:

 这个集合是按优先级排序的。(高优先级目录下的属性将覆盖低优先级目录下的属性)
 另外可以使用setSearchLocations(String)和setSearchNames(String)来指定搜索路径和文件名称。
 还将根据活动配置文件加载其他文件。 例如，如果“ Web”配置文件处于活动状态，则将考虑“ application-web.properties”和“ application-web.yml”。
 “ spring.config.name”属性可用于指定要加载的备用名称，“ spring.config.location”属性可用于指定备用搜索位置或特定文件。
 */

public class ConfigFileApplicationListener implements EnvironmentPostProcessor, SmartApplicationListener, Ordered {}

~~~

##### onApplicationEvent

~~~java
@Override
public void onApplicationEvent(ApplicationEvent event) {
    if (event instanceof ApplicationEnvironmentPreparedEvent) {
        // 加载系统变量
        onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent) event);
    }
    if (event instanceof ApplicationPreparedEvent) {
        // 加载配置文件
        onApplicationPreparedEvent(event);
    }
}
~~~

##### ApplicationEnvironmentPreparedEvent

~~~java
private void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) {
    List<EnvironmentPostProcessor> postProcessors = loadPostProcessors();
    postProcessors.add(this);
    AnnotationAwareOrderComparator.sort(postProcessors);
    for (EnvironmentPostProcessor postProcessor : postProcessors) {
        postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication());
    }
}
~~~

具体看 EnvironmentPostProcessor 部分

##### onApplicationPreparedEvent

~~~java
private void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) {
    List<EnvironmentPostProcessor> postProcessors = loadPostProcessors();
    postProcessors.add(this);
    AnnotationAwareOrderComparator.sort(postProcessors);
    for (EnvironmentPostProcessor postProcessor : postProcessors) {
        postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication());
    }
}

~~~

#### DelegatingApplicationListener

##### 概述

委托给在context.listener.classes环境属性下指定的其他侦听器的ApplicationListener 

##### onApplicationEvent

~~~java
@Override
public void onApplicationEvent(ApplicationEvent event) {
    if (event instanceof ApplicationEnvironmentPreparedEvent) {
        List<ApplicationListener<ApplicationEvent>> delegates = getListeners(
            ((ApplicationEnvironmentPreparedEvent) event).getEnvironment());
        if (delegates.isEmpty()) {
            return;
        }
        this.multicaster = new SimpleApplicationEventMulticaster();
        for (ApplicationListener<ApplicationEvent> listener : delegates) {
            this.multicaster.addApplicationListener(listener);
        }
    }
    if (this.multicaster != null) {
        this.multicaster.multicastEvent(event);
    }
}

~~~

~~~java
@SuppressWarnings("unchecked")
private List<ApplicationListener<ApplicationEvent>> getListeners(ConfigurableEnvironment environment) {
    if (environment == null) {
        return Collections.emptyList();
    }
    String classNames = environment.getProperty(PROPERTY_NAME);
    List<ApplicationListener<ApplicationEvent>> listeners = new ArrayList<>();
    if (StringUtils.hasLength(classNames)) {
        for (String className : StringUtils.commaDelimitedListToSet(classNames)) {
            try {
                Class<?> clazz = ClassUtils.forName(className, ClassUtils.getDefaultClassLoader());
                Assert.isAssignable(ApplicationListener.class, clazz,
                                    "class [" + className + "] must implement ApplicationListener");
                listeners.add((ApplicationListener<ApplicationEvent>) BeanUtils.instantiateClass(clazz));
            }
            catch (Exception ex) {
                throw new ApplicationContextException("Failed to load context listener class [" + className + "]",
                                                      ex);
            }
        }
    }
    AnnotationAwareOrderComparator.sort(listeners);
    return listeners;
}
private static final String PROPERTY_NAME = "context.listener.classes";

~~~

只有当环境准备完成事件发生的时候，然后获取通过配置的`context.listener.classes`属性来获取侦听器实例，然后把这些侦听器加到应用的侦听器集合里面，然后再次发布这个事件。

> ​		这个地方get到我们可以通过实现ApplicationListener的方式来自定义侦听器，通过`context.listener.classes`属性配置的方式将侦听器注册到Spring里面。
> ​		接着我们自定义的监听器就可以监听spring里面的事件了。

####  ClasspathLoggingApplicationListener

##### 简述

就是打印一个日志

##### onApplicationEvent

```java
@Override
public void onApplicationEvent(ApplicationEvent event) {
   if (logger.isDebugEnabled()) {
      if (event instanceof ApplicationEnvironmentPreparedEvent) {
         logger.debug("Application started with classpath: " + getClasspath());
      }
      else if (event instanceof ApplicationFailedEvent) {
         logger.debug("Application failed to start with classpath: " + getClasspath());
      }
   }
}
```





#### LoggingApplicationListener

##### 简述

~~~bash
LoggingApplicationListener是一个LoggingSystem配置的侦听器，如果环境中有配置logging.config属性，
那么这将用于引导启动日志系统，否则将采用默认配置。日志级别可以通过logging.level.*进行自定义，
日志组通过logging.group进行配置。
如果环境中包含为被设置成false的debug或trace属性，
那么Spring, Tomcat, Jetty 和 Hibernate 的Debug和trace日志将被启动。
（i.e. 如果你启动你的应用以这种方式：java -jar myapp.jar [–debug | --trace]，如果你想忽略这些属性，
你可以设置parseArgs为false[setParseArgs(boolean)方法]）
默认情况下，日志只会被输出到控制台，如果需要一个日志文件，通过配置logging.file.path和logging.file.name来实现。
有些系统设置可能会被作为侧面效果进行设置，如果日志配置支持占位符（i.e. log4j or logback），那么他们可以被用到。
~~~



##### onApplicationEvent

~~~java
@Override
public void onApplicationEvent(ApplicationEvent event) {
    if (event instanceof ApplicationStartingEvent) {
        // 启动事件
        onApplicationStartingEvent((ApplicationStartingEvent) event);
    }
    else if (event instanceof ApplicationEnvironmentPreparedEvent) {
        // 环境准备事件
        onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent) event);
    }
    else if (event instanceof ApplicationPreparedEvent) {
        // 应用准备事件
        onApplicationPreparedEvent((ApplicationPreparedEvent) event);
    }
    else if (event instanceof ContextClosedEvent
             && ((ContextClosedEvent) event).getApplicationContext().getParent() == null) {
        // 上下文关闭事件
        onContextClosedEvent();
    }
    else if (event instanceof ApplicationFailedEvent) {
        // 应用失败事件
        onApplicationFailedEvent();
    }
}

~~~

###### ApplicationStartingEvent

初始化日志系统

~~~java
private void onApplicationStartingEvent(ApplicationStartingEvent event) {
    this.loggingSystem = LoggingSystem.get(event.getSpringApplication().getClassLoader());
    this.loggingSystem.beforeInitialize();
}
~~~

###### loggingSystem

~~~java
/**
	 *一个System属性，可用于指示要使用的LoggingSystem 。
	 */
public static final String SYSTEM_PROPERTY = LoggingSystem.class.getName();
/**
	 *检测并返回正在使用的日志系统。支持Logback和Java日志记录。
	 * @param classLoader the classloader
	 * @return the logging system
	 */
public static LoggingSystem get(ClassLoader classLoader) {
    String loggingSystem = System.getProperty(SYSTEM_PROPERTY);
    if (StringUtils.hasLength(loggingSystem)) {
        if (NONE.equals(loggingSystem)) {
            return new NoOpLoggingSystem();
        }
        return get(classLoader, loggingSystem);
    }
    return SYSTEMS.entrySet().stream().filter((entry) -> ClassUtils.isPresent(entry.getKey(), classLoader))
        .map((entry) -> get(classLoader, entry.getValue())).findFirst()
        .orElseThrow(() -> new IllegalStateException("No suitable logging system located"));
}


~~~

​		从这里可以看到，我们是可以在通过配置系统属性org.springframework.boot.logging.LoggingSystem来指定采用哪个日志系统的，如果org.springframework.boot.logging.LoggingSystem的值是none，则会构建一个空操作日志系统（该日志系统不会做任何事情）。
​		如果没有系统配置，则会SYSTEMS中去选取一个存在的日志系统进行实例化。
​		看下SYSTEMS里面提供的日志系统有哪些：

~~~java
static {
    Map<String, String> systems = new LinkedHashMap<>();
    systems.put("ch.qos.logback.core.Appender", "org.springframework.boot.logging.logback.LogbackLoggingSystem");
    systems.put("org.apache.logging.log4j.core.impl.Log4jContextFactory",
                "org.springframework.boot.logging.log4j2.Log4J2LoggingSystem");
    systems.put("java.util.logging.LogManager", "org.springframework.boot.logging.java.JavaLoggingSystem");
    SYSTEMS = Collections.unmodifiableMap(systems);
}
~~~

##### ApplicationEnvironmentPreparedEvent

对日志系统进行一些设置

~~~java
private void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) {
    if (this.loggingSystem == null) {
        this.loggingSystem = LoggingSystem.get(event.getSpringApplication().getClassLoader());
    }
    initialize(event.getEnvironment(), event.getSpringApplication().getClassLoader());
}

protected void initialize(ConfigurableEnvironment environment, ClassLoader classLoader) {
    new LoggingSystemProperties(environment).apply();
    this.logFile = LogFile.get(environment);
    if (this.logFile != null) {
        this.logFile.applyToSystemProperties();
    }
    this.loggerGroups = new LoggerGroups(DEFAULT_GROUP_LOGGERS);
    initializeEarlyLoggingLevel(environment);
    initializeSystem(environment, this.loggingSystem, this.logFile);
    initializeFinalLoggingLevels(environment, this.loggingSystem);
    registerShutdownHookIfNecessary(environment, this.loggingSystem);
}
~~~



#### LiquibaseServiceLocatorApplicationListener

##### 概述

使用一个可以和 Spring Boot 可执行jar包配合工作的版本替换liquibase ServiceLocator

##### onApplicationEvent

~~~java
@Override
public void onApplicationEvent(ApplicationStartingEvent event) {
    if (ClassUtils.isPresent("liquibase.servicelocator.CustomResolverServiceLocator",
                             event.getSpringApplication().getClassLoader())) {
        new LiquibasePresent().replaceServiceLocator();
    }
}

~~~



## 初始化器--准备上下文执行

### ConfigurationWarningsApplicationContextInitializer

用作报告常见错误配置的警告（通过分析：如果系统配置包扫描（@ComponentScan）到了org或者org.springframework包就会发出警告并停止系统启动）

~~~java
@Override
public void initialize(ConfigurableApplicationContext context) {
    context.addBeanFactoryPostProcessor(new ConfigurationWarningsPostProcessor(getChecks()));
}
~~~

~~~java
protected Check[] getChecks() {
    return new Check[] { new ComponentScanPackageCheck() };
}
~~~

~~~java
protected static class ComponentScanPackageCheck implements Check {

    private static final Set<String> PROBLEM_PACKAGES;

    static {
        Set<String> packages = new HashSet<>();
        packages.add("org.springframework");
        packages.add("org");
        PROBLEM_PACKAGES = Collections.unmodifiableSet(packages);
    }

    @Override
    public String getWarning(BeanDefinitionRegistry registry) {
        Set<String> scannedPackages = getComponentScanningPackages(registry);
        List<String> problematicPackages = getProblematicPackages(scannedPackages);
        if (problematicPackages.isEmpty()) {
            return null;
        }
        return "Your ApplicationContext is unlikely to start due to a @ComponentScan of "
            + StringUtils.collectionToDelimitedString(problematicPackages, ", ") + ".";
    }

    protected Set<String> getComponentScanningPackages(BeanDefinitionRegistry registry) {
        Set<String> packages = new LinkedHashSet<>();
        String[] names = registry.getBeanDefinitionNames();
        for (String name : names) {
            BeanDefinition definition = registry.getBeanDefinition(name);
            if (definition instanceof AnnotatedBeanDefinition) {
                AnnotatedBeanDefinition annotatedDefinition = (AnnotatedBeanDefinition) definition;
                addComponentScanningPackages(packages, annotatedDefinition.getMetadata());
            }
        }
        return packages;
    }
    private void addComponentScanningPackages(Set<String> packages, AnnotationMetadata metadata) {
        AnnotationAttributes attributes = AnnotationAttributes
            .fromMap(metadata.getAnnotationAttributes(ComponentScan.class.getName(), true));
        if (attributes != null) {
            addPackages(packages, attributes.getStringArray("value"));
            addPackages(packages, attributes.getStringArray("basePackages"));
            addClasses(packages, attributes.getStringArray("basePackageClasses"));
            if (packages.isEmpty()) {
                packages.add(ClassUtils.getPackageName(metadata.getClassName()));
            }
        }
    }

    private void addPackages(Set<String> packages, String[] values) {
        if (values != null) {
            Collections.addAll(packages, values);
        }
    }

    private void addClasses(Set<String> packages, String[] values) {
        if (values != null) {
            for (String value : values) {
                packages.add(ClassUtils.getPackageName(value));
            }
        }
    }
    private List<String> getProblematicPackages(Set<String> scannedPackages) {
        List<String> problematicPackages = new ArrayList<>();
        for (String scannedPackage : scannedPackages) {
            if (isProblematicPackage(scannedPackage)) {
                problematicPackages.add(getDisplayName(scannedPackage));
            }
        }
        return problematicPackages;
    }
    private boolean isProblematicPackage(String scannedPackage) {
        if (scannedPackage == null || scannedPackage.isEmpty()) {
            return true;
        }
        return PROBLEM_PACKAGES.contains(scannedPackage);
    }
    private String getDisplayName(String scannedPackage) {
        if (scannedPackage == null || scannedPackage.isEmpty()) {
            return "the default package";
        }
        return "'" + scannedPackage + "'";
    }
}
~~~





### ContextIdApplicationContextInitializer

会在应用程序启动的时候初始化应用程序的唯一ID。

~~~java
@Override
public void initialize(ConfigurableApplicationContext applicationContext) {
    ContextId contextId = getContextId(applicationContext);
    applicationContext.setId(contextId.getId());
    applicationContext.getBeanFactory().registerSingleton(ContextId.class.getName(), contextId);
}
~~~



### DelegatingApplicationContextInitializer

负责读取核心配置文件 context.initializer.classes 配置项指定的初始化器，

并调用它们的 initialize() 方法来完成对应用上下文的初始化工作。 

~~~java
@Override
public void initialize(ConfigurableApplicationContext context) {
    ConfigurableEnvironment environment = context.getEnvironment();
    List<Class<?>> initializerClasses = getInitializerClasses(environment);
    if (!initializerClasses.isEmpty()) {
        applyInitializerClasses(context, initializerClasses);
    }
}
~~~



### RSocketPortInfoApplicationContextInitializer

 添加了监听器？

~~~java
@Override
public void initialize(ConfigurableApplicationContext applicationContext) {
    applicationContext.addApplicationListener(new Listener(applicationContext));
}
~~~



### ServerPortInfoApplicationContextInitializer

1. 本身是初始化器也是监听器
2. 将内置servlet容器实际使用的监听端口写入到`Environment`环境属性中。这样属性"local.server.port"就可以直接通过`@Value`注入到测试中，或者通过环境属性`Environment`获取。

~~~java
public class ServerPortInfoApplicationContextInitializer implements
		ApplicationContextInitializer<ConfigurableApplicationContext>, ApplicationListener<WebServerInitializedEvent> {

    @Override
    public void initialize(ConfigurableApplicationContext applicationContext) {
        applicationContext.addApplicationListener(this);
    }
    
    @Override
	public void onApplicationEvent(WebServerInitializedEvent event) {
		String propertyName = "local." + getName(event.getApplicationContext()) + ".port";
		setPortProperty(event.getApplicationContext(), propertyName, event.getWebServer().getPort());
	}
    
}
~~~





## 环境后置处理器 -- EnvironmentPostProcessor

### 组成

~~~bash
# Environment Post Processors
org.springframework.boot.env.EnvironmentPostProcessor=\
org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\
org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor,\
org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor,\
org.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor
~~~

### 执行流程

~~~java
private void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) {
    List<EnvironmentPostProcessor> postProcessors = loadPostProcessors();
    postProcessors.add(this);
    // 排序
    AnnotationAwareOrderComparator.sort(postProcessors);
    for (EnvironmentPostProcessor postProcessor : postProcessors) {
        postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication());
    }
}

~~~

![在这里插入图片描述](img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTA0OTU0NTQ1MA==,size_16,color_FFFFFF,t_70.png)

### PostProcessor

#### SystemEnvironmentPropertySourceEnvironmentPostProcessor

#### SpringApplicationJsonEnvironmentPostProcessor

#### CloudFoundryVcapEnvironmentPostProcessor

#### EnvironmentPostProcessor --读取配置文件



>  从常见的那些约定的位置读取配置文件，比如从以下目录读取application.properties,application.yml等配置文件：
>
> + classpath:
> + file:.
> + classpath:config
> + file:./config/:
>
> 也可以配置成从其他指定的位置读取配置文件

##### postProcessEnvironment

~~~java
@Override
public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
    addPropertySources(environment, application.getResourceLoader());
}


protected void addPropertySources(ConfigurableEnvironment environment, ResourceLoader resourceLoader) {
    RandomValuePropertySource.addToEnvironment(environment);
    new Loader(environment, resourceLoader).load();
}

Loader(ConfigurableEnvironment environment, ResourceLoader resourceLoader) {
    this.environment = environment;
    this.placeholdersResolver = new PropertySourcesPlaceholdersResolver(this.environment);
    this.resourceLoader = (resourceLoader != null) ? resourceLoader : new DefaultResourceLoader();
    this.propertySourceLoaders = SpringFactoriesLoader.loadFactories(PropertySourceLoader.class,
                                                                     getClass().getClassLoader());
}


private static final String DEFAULT_PROPERTIES = "defaultProperties";

private static final String DEFAULT_SEARCH_LOCATIONS = "classpath:/,classpath:/config/,file:./,file:./config/";

private static final String DEFAULT_NAMES = "application";



void load() {
    FilteredPropertySource.apply(this.environment, DEFAULT_PROPERTIES, LOAD_FILTERED_PROPERTY,
                                 (defaultProperties) -> {
                                     this.profiles = new LinkedList<>();
                                     this.processedProfiles = new LinkedList<>();
                                     this.activatedProfiles = false;
                                     this.loaded = new LinkedHashMap<>();
                                     // 初始化文件
                                     initializeProfiles();
                                     while (!this.profiles.isEmpty()) {
                                         Profile profile = this.profiles.poll();
                                         if (isDefaultProfile(profile)) {
                                             addProfileToEnvironment(profile.getName());
                                         }
                                         load(profile, this::getPositiveProfileFilter,
                                              addToLoaded(MutablePropertySources::addLast, false));
                                         this.processedProfiles.add(profile);
                                     }
                                     load(null, this::getNegativeProfileFilter, addToLoaded(MutablePropertySources::addFirst, true));
                                     addLoadedPropertySources();
                                     // 使用对应环境的配置文件
                                     applyActiveProfiles(defaultProperties);
                                 });
}

~~~







#### DebugAgentEnvironmentPostProcessor







## 创建Bean的流程-getBean()

### createBean（创建bean的准备工作）

~~~java
protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException {
    if (this.logger.isDebugEnabled()) {
        this.logger.debug("Creating instance of bean '" + beanName + "'");
    }

    RootBeanDefinition mbdToUse = mbd;
    Class<?> resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]);
    if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
        mbdToUse = new RootBeanDefinition(mbd);
        mbdToUse.setBeanClass(resolvedClass);
    }

    try {
        mbdToUse.prepareMethodOverrides();
    } catch (BeanDefinitionValidationException var7) {
        throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", var7);
    }

    Object beanInstance;
    try {
        beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse);
        if (beanInstance != null) {
            return beanInstance;
        }
    } catch (Throwable var8) {
        throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", var8);
    }

    beanInstance = this.doCreateBean(beanName, mbdToUse, args);
    if (this.logger.isDebugEnabled()) {
        this.logger.debug("Finished creating instance of bean '" + beanName + "'");
    }

    return beanInstance;
}

~~~



### doCreateBean（开始创建Bean）

可以看到大致逻辑如下：

1. createBeanInstance(beanName, mbd, args) ：实例化bean，将BeanDefinition转换为BeanWrapper
2. applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); ： MergedBeanDefinitionPostProcessor 后处理器的应用。bean合并后的处理，比如 @Autowired、@Value注解正是通过 
3. AutowiredAnnotationBeanPostProcessor#postProcessMergedBeanDefinition 此方法实现的预解析。
4. addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean)); ： 关于循环依赖的处理，添加 ObjectFactory到singletonFactories缓存中，同时这里给了用户一个机会通过调用 SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference 方法来由用户生成暴露的实例
5. populateBean(beanName, mbd, instanceWrapper); ：对创建的bean内部的一些属性进行填充注入
6. initializeBean(beanName, exposedObject, mbd); ： 初始化bean的一些属性，如Aware 接口的实现， init-method属性等
   循环依赖检查。和第四步不同的是，这里了是判断是否无法解决循环依赖，否则抛出异常。
7. registerDisposableBeanIfNecessary(beanName, bean, mbd); ： 注册DisposableBean
8. 完成创建并返回。

~~~java
// 保存的是 FactoryBean 的beanName -> FactoryBean 的 BeanWrapper
private final ConcurrentMap<String, BeanWrapper> factoryBeanInstanceCache = new ConcurrentHashMap<>();

protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
    throws BeanCreationException {

    // Instantiate the bean.
    BeanWrapper instanceWrapper = null;
    if (mbd.isSingleton()) {
        // 单例情况下清除缓存。这里保存的是 FactoryBean 和 BeanWrapper 的映射关系。 
        // factoryBeanInstanceCache 是在创建其他bean的时候缓存了一下 FactoryBean 。至于单例模式下移除而不是获取，因为单例只需要创建一次 ？ 尚未理解。
        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
    }
    // 如果没有缓存，则重新创建
    if (instanceWrapper == null) {
        // 1. 根据指定的bean使用对应的策略创建新的实例。如：工厂方法、构造函数自动注入，简单初始化
        instanceWrapper = createBeanInstance(beanName, mbd, args);
    }
    // 获取bean实例
    final Object bean = instanceWrapper.getWrappedInstance();
    // 获取bean类型
    Class<?> beanType = instanceWrapper.getWrappedClass();
    // 将目标类型替换成实际生成的类型.纠正了上面说到类型错误(如果存在)
    if (beanType != NullBean.class) {
        mbd.resolvedTargetType = beanType;
    }

    // Allow post-processors to modify the merged bean definition.
    // 2. 调用  MergedBeanDefinitionPostProcessor 后处理器
    synchronized (mbd.postProcessingLock) {
        if (!mbd.postProcessed) {
            try {
                // 调用  MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition 后处理器的方法。
                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
            }
            catch (Throwable ex) {
                throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                                "Post-processing of merged bean definition failed", ex);
            }
            mbd.postProcessed = true;
        }
    }

    // Eagerly cache singletons to be able to resolve circular references
    // even when triggered by lifecycle interfaces like BeanFactoryAware.
    // 3. 判断是否需要提早曝光 ： 单例 & 允许循环依赖 & 当前bean已经正在创建中
    // 由于当前bean已经在创建中，本次创建必然是循环引用造成的，所以这里判断是否可以需要提前曝光
    boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
                                      isSingletonCurrentlyInCreation(beanName));
    if (earlySingletonExposure) {
        if (logger.isTraceEnabled()) {
            logger.trace("Eagerly caching bean '" + beanName +
                         "' to allow for resolving potential circular references");
        }
        // 4. 为避免后期循环依赖，在bean初始化完成前将创建实例的ObjectFactory 加入工程  -- 解决循环依赖
        addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
    }

    // Initialize the bean instance.
    Object exposedObject = bean;
    try {
        //  5.1 对bean进行属性填充，将各个属性值注入，其中如果存在依赖于其他bean的属性，则会递归初始依赖bean
        populateBean(beanName, mbd, instanceWrapper);
        // 5.2 完成Bean的各类初始化工作，比如 init-method
        exposedObject = initializeBean(beanName, exposedObject, mbd);
    }
    catch (Throwable ex) {
        if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {
            throw (BeanCreationException) ex;
        }
        else {
            throw new BeanCreationException(
                mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex);
        }
    }
    // 6. 进行循环依赖检查
    if (earlySingletonExposure) {
        Object earlySingletonReference = getSingleton(beanName, false);
        // earlySingletonReference  只有在检测到有循环依赖的情况下才会不为空
        if (earlySingletonReference != null) {
            // 如果 exposedObject没有在初始化方法中被改变，也就是没有被增强
            if (exposedObject == bean) {
                exposedObject = earlySingletonReference;
            }
            else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
                String[] dependentBeans = getDependentBeans(beanName);
                Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
                for (String dependentBean : dependentBeans) {
                    // 检测依赖
                    if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                        actualDependentBeans.add(dependentBean);
                    }
                }
                // 因为bean创建后其所依赖的bean一定是已经创建了的。actualDependentBeans不为空说明当前 bean创建后其依赖的bena却没有全部创建完，也就说说存在循环依赖。
                if (!actualDependentBeans.isEmpty()) {
                    throw new BeanCurrentlyInCreationException(beanName,
                                                               "Bean with name '" + beanName + "' has been injected into other beans [" +
                                                               StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                                                               "] in its raw version as part of a circular reference, but has eventually been " +
                                                               "wrapped. This means that said other beans do not use the final version of the " +
                                                               "bean. This is often the result of over-eager type matching - consider using " +
                                                               "'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.");
                }
            }
        }
    }

    // Register bean as disposable.
    try {
        // 7.根据Scopse 注册bean
        registerDisposableBeanIfNecessary(beanName, bean, mbd);
    }
    catch (BeanDefinitionValidationException ex) {
        throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex);
    }

    return exposedObject;
}

~~~



### createBeanInstance（创建Bean实例）

见名知意 ： 该方法完成了bean的实例创建。

大概逻辑可以概括为：

1. 如果存在工厂方法则使用工厂方法进行初始化
2. 若类有多个构造函数，则根据参数锁定构造函数并初始化
3. 如果即不存在工厂方法也不存在带参构造函数，则使用默认的构造函数进行bean的实例化。

~~~java
	protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
		// Make sure bean class is actually resolved at this point.
		// 解析bean，获取class
		Class<?> beanClass = resolveBeanClass(mbd, beanName);
		// beanClass != null && 当前类不是public && 不允许访问非公共构造函数和方法。抛出异常
		if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {
			throw new BeanCreationException(mbd.getResourceDescription(), beanName,
					"Bean class isn't public, and non-public access not allowed: " + beanClass.getName());
		}
		// 1. 是否有bean的 Supplier 接口，如果有，通过回调来创建bean
		Supplier<?> instanceSupplier = mbd.getInstanceSupplier();
		if (instanceSupplier != null) {
			return obtainFromSupplier(instanceSupplier, beanName);
		}
		// 2. 如果工厂方法不为空，则使用工厂方法初始化策略
		// 通过 @Bean 注解方法注入的bean 或者xml 配置注入 的BeanDefinition 会存在这个值。而注入这个bean的方法就是工厂方法。后面会详细解读
		if (mbd.getFactoryMethodName() != null) {
			// 执行工厂方法，创建bean
			return instantiateUsingFactoryMethod(beanName, mbd, args);
		}

		// Shortcut when re-creating the same bean...
		// 3. 尝试使用构造函数构建bean，后面详解
		// 经过上面两步，Spring确定没有其他方式来创建bean，所以打算使用构造函数来进行创建bean。 但是 bean 的构造函数可能有多个，需要确定使用哪一个。
		// 这里实际上是一个缓存，resolved 表示构造函数是否已经解析完成；autowireNecessary 表示是否需要自动装配
		boolean resolved = false;
		boolean autowireNecessary = false;
		if (args == null) {
			synchronized (mbd.constructorArgumentLock) {
				// 一个类可能有多个不同的构造函数，每个构造函数参数列表不同，所以调用前需要根据参数锁定对应的构造函数或工程方法
				// 如果这个bean的构造函数或者工厂方法已经解析过了，会保存到 mbd.resolvedConstructorOrFactoryMethod 中。这里来判断是否已经解析过了。
				if (mbd.resolvedConstructorOrFactoryMethod != null) {
					resolved = true;
					autowireNecessary = mbd.constructorArgumentsResolved;
				}
			}
		}
		// 如果已经解析过则使用功能解析好的构造函数方法，不需要再次解析。这里的是通过 mbd.resolvedConstructorOrFactoryMethod 属性来缓存解析过的构造函数。
		if (resolved) {
			if (autowireNecessary) {
				// 4. 构造函数自动注入
				return autowireConstructor(beanName, mbd, null, null);
			}
			else {
				// 5. 使用默认构造函数构造
				return instantiateBean(beanName, mbd);
			}
		}

		// 6. 根据参数解析构造函数，并将解析出来的构造函数缓存到mdb 的  resolvedConstructorOrFactoryMethod  属性中
		// 到这一步，说明 bean 是第一次加载，所以没有对构造函数进行相关缓存(resolved 为 false)
		// 调用 determineConstructorsFromBeanPostProcessors  方法来获取指定的构造函数列表。后面详解
		Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
		
		if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
				mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
			return autowireConstructor(beanName, mbd, ctors, args);
		}

		// Preferred constructors for default construction?
		// 获取最优的构造函数
		ctors = mbd.getPreferredConstructors();
		if (ctors != null) {
			// 构造函数自动注入
			return autowireConstructor(beanName, mbd, ctors, null);
		}

		// No special handling: simply use no-arg constructor.
		// 使用默认构造函数构造
		return instantiateBean(beanName, mbd);
	}

~~~



###  applyMergedBeanDefinitionPostProcessors（合并属性）

~~~java
applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);

protected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class<?> beanType, String beanName) {
    for (BeanPostProcessor bp : getBeanPostProcessors()) {
        if (bp instanceof MergedBeanDefinitionPostProcessor) {
            MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;
            bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);
        }
    }
}
~~~



### addSingletonFactory（解决循环依赖）

~~~java
boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
                                  isSingletonCurrentlyInCreation(beanName));
if (earlySingletonExposure) {
    if (logger.isTraceEnabled()) {
        logger.trace("Eagerly caching bean '" + beanName +
                     "' to allow for resolving potential circular references");
    }
    // 这里为了避免后期的循环依赖，在bean初始化前将创建实例的ObjectFactory加入工厂中。
    addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
}
~~~

首先我们需要分析出 earlySingletonExposure 为true的条件：

+ bean是单例
+ 允许循环依赖
+ 当前bean正在创建中 ： singletonsCurrentlyInCreation 包含当前bean。在Spring 中 有专门的属性记录 bean的加载状态 -DefaultSingletonBeanRegistry#singletonsCurrentlyInCreation。在bean创建前会将bean添加，bean创建结束后将bean移除。这一点我们在前篇有过提及。

满足上述三个条件后，则会 调用 addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean)); 方法。这个方法作用是将正在创建的bean缓存起来，主要目的还是用来解决循环依赖的问题。

### populateBean（属性注入）

见名知意，下面这个方法是用来属性注入的。
populateBean 方法则是对bean 属性的注入，上面的 createBeanInstance 方法创建了 bean，但是其内部属性并没有注入，比如通过 @Autowired 注解注入的变量属性，此时还为null，需要对这种属性进行注入，这一步就是完成这种功能。

~~~java
populateBean(beanName, mbd, instanceWrapper);
~~~

在这里方法里按照如下顺序调用了后处理器

+ InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation ： 返回true 才会调用下面两个方法
+ InstantiationAwareBeanPostProcessor.postProcessProperties ： 进行属性的注入。
+ InstantiationAwareBeanPostProcessor.postProcessPropertyValues ： 已过时

### initializeBean（初始化Bean）

到达这一步，其实bean已经创建结束了，这一步是完成最后的功能，提供一些功能的实现，如Aware 接口的实现， init-method、InitializingBean属性等。

~~~java
exposedObject = initializeBean(beanName, exposedObject, mbd);

protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {
    // 对特殊的bean进行处理 ： 实现了 Aware、BeanClassLoaderAware、BeanFactoryAware 的处理。后面详解
    if (System.getSecurityManager() != null) {
        AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
            // 激活 Aware  方法
            invokeAwareMethods(beanName, bean);
            return null;
        }, getAccessControlContext());
    }
    else {
        invokeAwareMethods(beanName, bean);
    }

    Object wrappedBean = bean;
    if (mbd == null || !mbd.isSynthetic()) {
        // 调用了bean后处理器的方法
        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
    }

    try {
        // 激活自定义的init的方法。
        invokeInitMethods(beanName, wrappedBean, mbd);
    }
    catch (Throwable ex) {
        throw new BeanCreationException(
            (mbd != null ? mbd.getResourceDescription() : null),
            beanName, "Invocation of init method failed", ex);
    }
    if (mbd == null || !mbd.isSynthetic()) {
        // 调用bean后处理器的方法
        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
    }

    return wrappedBean;
}

~~~

上面关于两个后处理器的调用，本文就不再赘述了，分别调用了 `BeanPostProcessor. postProcessBeforeInitialization`、`BeanPostProcessor.postProcessAfterInitialization` 方法。





#### invokeAwareMethods

方法很简单，完成了 Aware 接口的激活功能。可以简单的说 ：

1. 如果bean实现了BeanNameAware 接口，则将 beanName设值进去
2. 如果bean实现了BeanClassLoaderAware接口，则将 ClassLoader 设值进去
3. 如果bean实现了BeanFactoryAware接口，则将 beanFactory 设值进去

~~~java
private void invokeAwareMethods(final String beanName, final Object bean) {
    if (bean instanceof Aware) {
        // 判断是否是实现了 BeanNameAware
        if (bean instanceof BeanNameAware) {
            ((BeanNameAware) bean).setBeanName(beanName);
        }
        
        // 判断是否实现了 BeanClassLoaderAware
        if (bean instanceof BeanClassLoaderAware) {
            ClassLoader bcl = getBeanClassLoader();
            if (bcl != null) {
                ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);
            }
        }
        
        // 判断是否实现了 BeanFactoryAware
        if (bean instanceof BeanFactoryAware) {
            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);
        }
    }
}
~~~



#### invokeInitMethods 

激活自定义的init方法

1. 首先需要注意的是，Bean 的初始化方法除了可以使用 init-method 属性(或者 @Bean(initMethod=''”))，还可以通过实现InitializingBean接口，并且在afterPropertiesSet 方法中实现自己初始化的业务逻辑。
2. 调用顺序则是 afterPropertiesSet 先调用，后面调用 init-method 指定的方法

~~~java

	protected void invokeInitMethods(String beanName, final Object bean, @Nullable RootBeanDefinition mbd)
			throws Throwable {
        
        // 判断是否实现了 InitializingBea
		boolean isInitializingBean = (bean instanceof InitializingBean);
		if (isInitializingBean && (mbd == null || !mbd.isExternallyManagedInitMethod("afterPropertiesSet"))) {
			if (logger.isTraceEnabled()) {
				logger.trace("Invoking afterPropertiesSet() on bean with name '" + beanName + "'");
			}
			// 调用 afterPropertiesSet  方法
			if (System.getSecurityManager() != null) {
				try {
					AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> {
						((InitializingBean) bean).afterPropertiesSet();
						return null;
					}, getAccessControlContext());
				}
				catch (PrivilegedActionException pae) {
					throw pae.getException();
				}
			}
			else {
                // 调用 InitializingBean 的 afterPropertiesSet 方法
				((InitializingBean) bean).afterPropertiesSet();
			}
		}
		
		if (mbd != null && bean.getClass() != NullBean.class) {
			// 从RootBeanDefinition 中获取initMethod 方法名称
			String initMethodName = mbd.getInitMethodName();
			// 调用initMethod 方法。
			if (StringUtils.hasLength(initMethodName) &&
					!(isInitializingBean && "afterPropertiesSet".equals(initMethodName)) &&
					!mbd.isExternallyManagedInitMethod(initMethodName)) {
				invokeCustomInitMethod(beanName, bean, mbd);
			}
		}
	}

~~~







### 循环依赖检查

Spring 循环依赖的解决仅对单例且非构造函数构造的形式有效，对于原型模式的bean，Spring直接抛出异常，在这个步骤中会检测已经加载的bean 是否已经出现了循环依赖，并判断是否需要抛出异常。

~~~~java
// earlySingletonExposure 为true 说明要校验循环依赖的问题
if (earlySingletonExposure) {
    // 调用了 getSingleton 方法获取缓存中的对象，这里注意传递的false。
    Object earlySingletonReference = getSingleton(beanName, false);
    // 如果 earlySingletonReference  不为空，则说明存在循环依赖
    if (earlySingletonReference != null) {
        // 如果缓存的对象 exposedObject == bean，直接赋值之前暴露出来的bean
        // 这里
        if (exposedObject == bean) {
            exposedObject = earlySingletonReference;
        }
        // allowRawInjectionDespiteWrapping 默认false && beanName 被其他bean依赖
        else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
            // 获取依赖于 当前bean的 beanName
            String[] dependentBeans = getDependentBeans(beanName);
            Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
            for (String dependentBean : dependentBeans) {
                // 
                if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                    actualDependentBeans.add(dependentBean);
                }
            }
            // 如果 actualDependentBeans 不为空，则抛出循环依赖的异常
            if (!actualDependentBeans.isEmpty()) {
                throw new BeanCurrentlyInCreationException(beanName,
                                                           "Bean with name '" + beanName + "' has been injected into other beans [" +
                                                           StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                                                           "] in its raw version as part of a circular reference, but has eventually been " +
                                                           "wrapped. This means that said other beans do not use the final version of the " +
                                                           "bean. This is often the result of over-eager type matching - consider using " +
                                                           "'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.");
            }
        }
    }
}

...
    // 上面调用的 getSingleton 方法。可以知道这里传递的 allowEarlyReference 为false。
    // 因为当前bean在进行循环创建的时候，就已经将 bean缓存到 earlySingletonObjects 中了
    @Nullable
    protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
        synchronized (this.singletonObjects) {
            singletonObject = this.earlySingletonObjects.get(beanName);
            if (singletonObject == null && allowEarlyReference) {
                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                if (singletonFactory != null) {
                    singletonObject = singletonFactory.getObject();
                    this.earlySingletonObjects.put(beanName, singletonObject);
                    this.singletonFactories.remove(beanName);
                }
            }
        }
    }
    return singletonObject;
}

...
    // 删除给定bean名称的单例实例（如果有的话），但前提是该类型仅用于类型检查以外的用途。
    protected boolean removeSingletonIfCreatedForTypeCheckOnly(String beanName) {
    if (!this.alreadyCreated.contains(beanName)) {
        removeSingleton(beanName);
        return true;
    }
    else {
        return false;
    }
}

...
    protected void removeSingleton(String beanName) {
    synchronized (getSingletonMutex()) {
        super.removeSingleton(beanName);
        this.factoryBeanObjectCache.remove(beanName);
    }
}
...
    // super.removeSingleton(beanName); 如下
    protected void removeSingleton(String beanName) {
    synchronized (this.singletonObjects) {
        this.singletonObjects.remove(beanName);
        this.singletonFactories.remove(beanName);
        this.earlySingletonObjects.remove(beanName);
        this.registeredSingletons.remove(beanName);
    }
}

~~~~



### registerDisposableBeanIfNecessary（销毁）

这一步的目的是实现 destory-method 属性，如果bean配置了该属性，则需要注册以便在销毁时调用。

~~~java
protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) {
    AccessControlContext acc = (System.getSecurityManager() != null ? getAccessControlContext() : null);
    if (!mbd.isPrototype() && requiresDestruction(bean, mbd)) {
        if (mbd.isSingleton()) {
            // Register a DisposableBean implementation that performs all destruction
            // work for the given bean: DestructionAwareBeanPostProcessors,
            // DisposableBean interface, custom destroy method.
            // 单例模式下注册需要销毁的bean，此方法会处理实现DisposableBean的bean
            // 并且对所有的bean使用 DestructionAwareBeanPostProcessor 处理 DisposableBean DestructionAwareBeanPostProcessor
            registerDisposableBean(beanName,
                                   new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
        }
        else {
            // A bean with a custom scope...
            // 自定义 scope 的处理
            Scope scope = this.scopes.get(mbd.getScope());
            if (scope == null) {
                throw new IllegalStateException("No Scope registered for scope name '" + mbd.getScope() + "'");
            }
            scope.registerDestructionCallback(beanName,
                                              new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
        }
    }
}

~~~

## Spring的复杂继承体系

### 概述

关于Spring源码中重要的接口主要有以下几个：

1. BeanFactory
2. BeanDefinition
3. ApplicationContext

![image-20240213105451436](img/image-20240213105451436.png)



BeanFactory是Spring中创建bean实例的接口，BeanDefinition接口是对配置文件中bean定义的抽象，ApplicationContext是Spring中重要的上下文类。

接口从整体上看分为了四层：

1. BeanFactory
2. ListableBeanFactory、AutowireCapableBeanFactory、HierachicalBeanFactory
3. ConfigurableBeanFactory
4. ConfigurableListableBeanFactory



### ListableBeanFactory

从名字上面看我们就大概能猜出来这是一个提供了遍历bean实例方法的接口.当然,工厂并没有直接提供返回所有实例的方法，也没这个必要。它可以返回指定类型的所有的实例。而且你可以通过 getBeanDefinitionNames()得到工厂所有bean的名字,然后根据这些名字得到所有的Bean。这个工厂接口扩展了 BeanFactory的功能，作为上文指出的BeanFactory二级接口，有9个独有的方法，扩展了跟BeanDefinition的功能，提供了BeanDefinition、BeanName、注解有关的各种操作。

### **HierarchicalBeanFactory**

这个工厂接口非常简单,实现了Bean工厂的分层。这个工厂接口也是继承自BeanFacotory，也是一个二级接口，相对于父接口，它只扩展了一个重要的功能。

### **AutowireCapableBeanFactory**

这个工厂接口继承自BeanFacotory，它扩展了自动装配的功能，根据类定义BeanDefinition装配Bean、执行前、后处理器等。

### ConfigurableListableBeanFactory

工厂接口 ConfigurableListableBeanFactory 同时继承了3个接口, ListableBeanFactory 、 AutowireCapableBeanFactory 和 ConfigurableBeanFactory，扩展之后,加上自有的这8个方法，这个工厂接口总共有83个方法，实在是巨大到不行了。这个工厂接口的自有方法总体上只是对父类接口功能的补充，包含了 BeanFactory 体系目前的所有方法，可以说是BeanFactory接口的集大成者。

### **BeanDefinitionRegistry**

这是一个内部接口，主要作用是用来操作定义在工厂内部的BeanDefinition的。

