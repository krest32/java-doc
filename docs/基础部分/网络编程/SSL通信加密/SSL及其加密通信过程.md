##  什么是SSL

SSL英文全称Secure Socket Layer，安全套接层，是一种为网络通信提供安全以及数据完整性的安全协议，它在传输层对网络进行加密。它主要是分为两层：

+ SSL记录协议：为高层协议提供安全封装、压缩、加密等基本功能
+ SSL握手协议：用于在数据传输开始前进行通信双方的身份验证、加密算法的协商、交换密钥

OpenSSL是SSL的开源实现，它是作为密码学的安全开发包，提供相当强大全面的功能，囊括了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议，并提供了丰富的应用程序供测试或其它目的使用。它一共提供了8中对称加密算法和4中非对称加密算法。



## HTTPS和SSL

​		HTTP（Hyper TEXT Transfer Protocol超文本传输协议）是目前互联网上应用最为广泛的一种网络协议，用于在Web浏览器和网站服务器之间传递信息，但是HTTP协议以明文的方式发送内容，不提供任何数据加密，所以HTTP不适合传输一些比较私密的信息，为了解决这一缺陷，HTTPS协议出现。**HTTPS是在HTTP的基础上加入SSL协议**。传输以密文传输，保证数据传输的安全以及确认网站的真实性（数字证书）。

~~~
HTTPS=HTTP+SSL
~~~



## `SSL`加密方式

### 加密方式

在开始之前首先得对理解对称加密与非对称加密这两种加密方式。其中加密过程是

信息+密钥+算法=密文

#### 对称加密

​		对称加密实质加密和解密都使用同一个密钥，对称加密只有一个密钥，作为私钥。这就好比现实生活中的钥匙和锁，我将想要传达的信息通过对称加密算法用私钥进行加密，形成密文，然后将这密文传送给同样拥有这把锁的“钥匙”的人，对方就用同样的算法和私钥将密文解密出来。
​		常用的对称加密算法有`DES`和`AES`等
​		但是在现实中，这种传输方式并不是特别方便，密钥怎么给对方是一个很关键的问题，而且密钥交给了其他人自己也不是很放心。于是非对称加密出现

#### 非对称加密

​		非对称加密是指加密和解密用的是不同密钥，并且是成对存在的。一把称为公钥，能够放心的交给别人，一把是私钥，只能自己保存。其中用公钥加密的信息只能用私钥解密，用私钥加密的信息只能用公钥解密。

![image-20210415235820153](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210415235820.png)

​		需要注意的是这里的私钥和密钥都是对应的，就是说我的私钥可以解密用我的公钥加密的信息，但是他人的私钥不能解密用我的公钥加密的信息。

​		常用的非对称加密算法有：RSA，DH，DSA三种

### 加密过程

我通过一段具体的通信过程来模拟这一加密过程。假设主人公是客户端A和服务端B

~~~
A：B，你好，我想向你发一段消息，请你把你的公钥给我
B：好的，我的公钥是：xxxxxxx。
A：好的，我收到了你的公钥，我给你发送的消息经过你的公钥加密后是：yyyyyyy。
B：收到，我现在用我的密钥来解密看看。
~~~

​		这就是非对称加密的具体过程，这种方式看上去很安全，但是仔细想想信息真的可靠吗？
​		想一想客户端A的公钥是假的怎么办？如果有一个黑客C也给客户端A发送了一个自己的公钥，而客户端A不知道公钥的正确性，用了C的公钥加密发送，这样一来，信息被C截取的化，信息不久泄露了吗。
​		所以我们得想个办法证明我用的公钥确实是服务端B的公钥。==于是数字证书出现！==我先抛一段官方的数字证书的概念

~~~
数字证书就是互联网通讯中标志通讯各方身份信息的一串数字，
提供了一种在Internet上验证通信实体身份的方式，数字证书
不是数字身份证，而是身份认证机构盖在数字身份证上的一个章
或印（或者说加在数字身份证上的一个签名）。
~~~

简单来说数字证书就是一段信息，他内部的信息包括：

> 签发证书的机构
> 加密算法
> Hash算法
> 公钥
> 证书到期时间等


## 我们梳理一下

+ 第一步 ：客户端A开启一个新的浏览器访问客户端时，会先让A安装一个数字证书，这个证书主要包含的是CA机构的公钥。
+ 第二步：服务端B发来CA机构给自己的证书，通过CA公钥解密被CA私钥加密的`hash1`，然后再用B的证书里面的hash算法将信息生成一个`hash2`，通过比较两个`hash`，若相等，确认这个数字证书是服务端B的。

由于非对称加密算法复杂度和计算量大，对称加密效率高，`SSL`就将这两种加密算法混合着用，这样安全和效率就都能保证了。其中具体的过程如下：

+ 第一步 客户端A给出 支持的`SSL`版本+一个随机数+自己支持的加密方式
+ 第二步 服务端B接收到这些信息后确认加密方式+自己的安全证书+一个随机数发给A
+ 第三步 客户端A确认数字证书有效性（验证方法上面已经说明），然后生成一个随机数，并将这个随机数用B的数字证书公钥加密后发送给A。
+ 第四步 服务端B使用自己的私钥解密这个随机数
+ 第五步 A和B通过第二步确定的加密方法将前三个随机数生成一个对话密钥 用来接下来的通信（个人感觉不需要三个随机数，只用最后一个就够了，这样做可能是为了更安全）

于是A和B救恩那个用对称加密的方式快速有效安全的通信了。
