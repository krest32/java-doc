# Java高级

## 基础部分

### 谈谈对于Java的理解？

1. 什么是Java？
2. Java的应用场景？
3. Java有什么特点？
4. 对比其他语言？

### 谈谈你对于枚举的理解？

1. 什么是枚举？
2. 枚举有什么特点？
3. 枚举可以做哪些事情？

### 谈谈你对于面向对象的理解？

1. 什么是面向对象？（顺便解释面向过程）
2. 面向对象编程的6大原则？
3. 什么是API和SPI？
4. 抽象类和抽象接口的区别？
5. 两个不同对象的HashCode也可能会相同，所以才会有equal方法，当Hashcode相同时，就是用Equal进行比较

### 谈谈你对于IO的理解？

1. 什么是IO？
2. IO的分类有哪些？输入、输出、字节、字符、文件、BIO、NIO、AIO
3. BIO、NIO、AIO的使用场景？
4. 如何优化IO的使用场景？
5. 扩展Linux IO？
   1. 多路复用
      1. select 和 poll 都是基于轮询的方式
      2. epoll 基于事件驱动的方式，性能比前两者更高一些

### Java中有几种文件拷贝的方法，哪种欧率最高？

+ 使用 io 包 inputStream
+ 使用 nio 包中的 transferTo 或 transferFrom
  + 实现了零拷贝，性能上比较高
+ 使用File.copy()

### 谈谈你对于序列化的理解？

1. 什么是序列化？
2. 序列化如何实现？
3. 关键字transient左右？
4. 现在主流的序列化方式有哪些？
  1. 同样的内容，Json是protobuf内存占用大概三倍左右

5. 序列化协议该如何选择？

### 谈谈你对与异常的理解？

1. 什么是异常？
2. 异常有哪些分类？
3. 常见的异常有哪些？
4. 异常的处理方案？
5. 生产中，异常的最佳生产实践

### 谈谈你对于泛型的理解？

1. 什么是泛型？
2. 为什么要使用泛型？
3. 泛型擦除（类型擦除）的概念？

### 谈谈你对于集合容器的理解？

1. 什么是集合框架？
2. Java的Util包下，有哪些集合的接口和类？

1. HashMap相关问题
2. 负载因子为什么是0.75？
3. 什么时候链表转化位红黑树？
4. 扩容上面都做了哪些优化？
5. 为什么每次扩容为2倍？
6. 对比HashTable，为什么可以插入 null 元素？

### 谈谈你对于网络编程的了解？

1. 什么是网络编程？

      网络编程是指网络上的主机通过不同的进程，以编程的方式实现网络信息传输。而提到网络编程的话，就需要知道一个网络编程套接字socket（操作系统提供的网络编程的API），**这是传输层和应用层之间进行调用的接口**，也就是操作系统给应用程序提供的API，一调用这个就可以和内核之间进行信息传递，那么在传输层内两个主要的协议TCP/UDP，就得了解。

2. TCP/IP 如何分层？

   1. TCP通常应用层协议：http、https、FTP、SMTP、SSH

   2. UDP通常应用层协议：NTP（适用于网络同步）、DHCP（动态路配置IP地址由）

3. 描述一次网络传输的流程？

4. 为什么会有三次握手、四次握手（等待2ML的原因）？（建立可靠连接，确保数据传输完毕）

5. Http与Https，其中SSL的工作方式？

6. 常用的网络状态码有哪些？

### 谈谈你对并发编程的理解？

1. 什么是并发编程/多线程？
2. 并发编程的三要素？
3. 谈谈对于线程安全的理解？
   1. 什么是线程安全？
   2. 出现线程安全的原因有哪些？
   3. 解决方法有哪些？
4. 线程相关
   1. 创建线程的方式
   2. Future、FutrueTask、CompleteFuture之间的区别？
5. 线程安全方式之间的对比？synchronized 与 lock
   1. Synchronized锁升级的过程？
   2. ReentrantLock 的理解？
  6. 概念、特性、实现原理（如何实现  可重入锁?）
7. 创建线程的方式有哪些？
8. 线程池相关
  9. 线程池的七大参数？
  10. 线程池线程复用的原理：实现了线程和任务之间的分离，当然任务需要执行值，之间交给线程，执行run方法即可
  11. 线程池的工作原理？
12. 并发容器有哪些？
13. 并发工具类 countDownLatch 和 Semphere
   14. countDownLatch ：底层实现，使用 await 会阻塞，等待所有事项一起完成再
   15. Semphere：相当于是一个许可，有几个停车位

1. 如何设置一个线程池的大小？

      1. 原则：CPU密集型（大量计算的工作），线程越少如果是IO密集型，CPU的线程数可以更大一些
      2. 线程平均工作的时间越长，线程数就应该越少，线程平均等待时间比例越高，线程数就应该越多
      3. 针对不同的业务场景，需要通过压测，然后调整线程数，获得一个最合适的数量

### 谈谈你对与JVM的理解？

1. 什么是JVM？
2. JVM有哪些分类？
3. JVM的主要组成部分，以及各个部分的功能？
4. 一个空的Java Object对象占用多大内存？
5. JVM的最大特点是什么？自动的垃圾回收机制？
6. 垃圾收集器有哪些种类？相互之间如何组合工作？
7. 类加载器的工作原理？
8. 每天100w次登陆请求，如何设置JVM参数？
9. 使用Arthas排查JVM的问题？

### Class 文件解析？

## 数据存储

### 谈谈你对与Mysql的理解？

+ 为什么要使用数据库？
+ 为什么选择Mysql？
+ 常用的字段类型有哪些？
+ Mysql的存储引擎？
+ Mysql的索引结构（分类、设计原则、索引优化原则）？
+ 谈谈什么是事务？Mysql 如何实现ACID？
+ 什么是MVCC？
+ 脏读、不可重复读、幻读、事务的隔离级别
+ 如何存储 IP地址？
  + 应该使用整数，如果使用varchar的话，占用的内存会增加多
  + Mysql 自带函数，也可以将 ip 转化为整数

### Mysql的两阶段提交？



### 常见的Mysql集群模式

+ 主从服务器
+ 分片中间件：MayCat+shardingJDBC
  + 适合10亿级别的数量总集的大型应用，
  + 如果超过这个数据量采用大数据解决方案更好
+ MHA高可用

### 谈谈你对于Sql的理解？

+ 什么是Sql？
+ Sql的执行顺序是怎么样的？
+ 什么是Sql优化？
+ 如何进行Sql优化？
  + Sql或者数据库设计不合理
    + 找到需要优化的Sql： 数据库慢查询日志，找到慢的 Sql
    + 需要增加索引的，增加索引，如果还是慢，判断是否走了索引？
    + 删减无用字段
    + 优化繁杂的子查询，删除无用的索引
    + 使用explain进行分析，然后优化不合理里的Sql
  + 数据量太大
    + 如果走了索引，但仍然比较慢，数据库？-分库分表
    + 水平拆分和垂直拆分
  + 数据库负载过高
    + 增加从库，读写分离
    + 热点数据查询？-增加缓存

### 谈谈你对于Redis的理解？

1. 为什么要使用缓存？
2. 什么是Redis？
3. Redis为什么高性能？
4. Redis的数据结构有哪些？
5. 关于Redis的持久化机制的理解？（高性能和数据0丢失方面，往往只能够满足一个条件）
6. Redis的过去Key删除策略？
7. Redis的内存淘汰策略？ 8种
8. 常见的缓存问题？缓存雪崩、缓存穿透、缓存击穿、双写一致性
9. Redis 的慢查询记录？
10. Redis分布式锁的使用？
11. Redis 对于高并发高可用的实现
    1. 单台可以实现几万的并发读写，提升读的吞吐量，可以使用主从，实现读写分离，不推荐开启master的节点开启热备，避免重启后，删除了从节点的数据
    2. 为了保证高可用，可以加入哨兵机制，实现主备切换
    3. 想要实现水平扩容，可以加入Reids的集群
12. Redis 进行性能优化？
    1. 尽可能缩短键值对的长度，减少内存在占用，也可以存储2机制的形式
    2. 使用延迟删除特性，避免频繁删除
    3. 设置键值对的过期时间
    4. 禁止耗时长的查询命令
    5. 使用Slowlog优化耗时命令
    6. 避免大量数据的同时失效
    7. 限制Redis内存的大小
    8. 检查持久化策略
    9. 使用分布式架构增加吞吐量



### 缓存的使用中，公司的编码规范有哪些？

1. 主从模式下，主从节点一定要分机器部署，避免单点鼓掌
2. 一定通网络部署，同交换机最佳，时间<2ms，否则意义不大
3. 单个节点的内存不宜太大，否则容易影响性能，如果数据过多，建议从业务上拆分，一般不超过10G
4. 对象不应该太大，1K级别最好，超过10K要特别小心
5. 如果对象存在复杂结构，最好使用HAsh，List等其他结构
6. 若无强烈持久化需求，不建议开启AOF
7. 一定防止Key的集中过期
8. 线上建议加密直连
9. 上线时最好基准测试，预估Redis的性能



### 谈谈你对于ES的理解？

### 谈谈你对于zk的理解？

### 谈谈对于一致性哈希算法的理解？

### 谈谈你对于Mybatis的理解？

1. 什么是ORM框架？
2. 原始数据库编程的痛点？
3. 什么是Mybatis？
4. Mybatis的工作流程是什么样的？
5. 插件机制的实现原理？

1. 数据库链接池的参数有哪些？

### 远程调用都有哪些实现方式？

1. 根据链接方式建立可以分为TCP、UDP
   1. Tcp会更加稳定一些
   2. Udp效率会更高
2. 可以链接的维持方式，可以分为：长连接、短链接（Http）、单工通道、双工通道
3. 根据传输协议，可以有Sop（Xml）、Http（Json）、RPC（二进制）、自定义协议传输
   1. Sop 重量级，解析Xml也会比较损失性能
   2. Http 目前比较流行，虽然单独用在远程调用上比较浪费资源，但是可以做到不同语言系统之间的调用
   3. RPC 基于二进制的传输协议，性能比较高，但是一般只用于同语言的系统之间
   4. GRPC 目前可以跨语言支持RPC，支持C、Java、Python、Golang
   5. 根据阻塞状态， 可以分为同步阻塞与同步非非阻塞

### 与外部系统链接需要注意什么？

+ 定义接口文档：路径、传参、返回、异常、超时时间等
+ 异常处理：接口返回异常的处理方式
+ 日志收集：接口入参、出参、异常信息记录
+ 超时处理：抛出异常、失败重试
+ 涉及分布式事务：事务应该采用哪种实现方式？

## 框架部分

### 谈谈你对于Spring的理解？

+ 什么是Spring？
+ 为什么要使用Spring？
+ Spring的组成模块有哪些？
+ IOC的实现原理是什么样的？
+ 什么是循环依赖？循环依赖的分类？循环依赖如何解决？
+ AOP的实现原理是什么样的？

### 谈谈你对于Spring Boot的理解？

+ 什么是Spring Boot？
+ Spring Boot自动装配的原理是怎么样的？
+ 如何自定义Starter？

### 谈谈你对于Spring Cloud的理解？

+ 什么是Spring cloud?
+ Spring Cloud 对比 Dubbo，如何？
+ 它和Spring Boot之间的关系是什么样的？
+ Spring Cloud的组成有哪些？各自负责什么样的功能？

### 谈谈你对于Netty的理解？

+ 什么是netty？
+ Netty 对比原生 Jdk Nio?
+ Netty 高性能的原因有哪些？
+ Netty 的组件有哪些？

  bootsrap、selector、channel、channelPipeline、channelHandler、channelFuture、NioEventLoop、NioEventLoopGroup
+ Netty 的使用场景有哪些？

### 谈谈你对于消息队列的理解？

+ 什么是消息队列？
+ 为什么要使用消息队列？
+ 主流消息队列的对比？
+ 你们公司选择了哪个消息队列？为什么？
+ 常见的消息队列问题
  + 消息的可靠传输？
  + 消息的顺序消费？
  + 如何避免消息的重复消费？
  + 消息事务？
  + 消息积压的问题如何处理

## 消息队列

### 谈谈你对于Kafka的理解

1.  高性能的原因？
2. 批量、零拷贝、顺序读写、数据压缩

### 谈谈你对于RocketMQ的

1. Rocket MQ 为什么放弃Zookeeper
2. RocketMQ 高性能的原因
  + 顺序写：顺序写比随机写的性能会高很多，不会有大量寻址的过程
  + 异步刷盘：相比较于同步刷盘，异步刷盘的性能会高很多
  + 零拷贝：提高了数据传输的效率
3. 如何实现事务消息?

+ 设计一个消息队列，你会怎么做？

  + MQ的水平扩容，增加吞吐量：那么可以参考Kafka在Topc下面增加Partition的方式，如果需要增加吞吐量，那么只需要水平增加机器和Paitition即可
  + 高性能持久化：顺序写磁盘的方式，减少机器随机读写
  + 保证高可用：可以采用多副本的机制
  + 数据的另丢失

### 阻塞队列被异步消费如何去保证消费的顺序？

+ 阻塞队列本来符合FIFO的规则
+ 消费的线程也可以采用类似阻塞队列的方式进行排队，按顺序消费任务

## 云原生

### 谈谈你对于Docker的理解？

+ 什么是Docker？
+ 为什么使用Docker？
+ 关于Docker File?

### 谈谈你对于云原生的理解？

+ Cloud+Native
+ 四个要素
  + 微服务
  + 容器化
  + 支持Devops
  + 持续交付 CICD

### 为什么要使用云原生？

### 什么是K8s？

+ K8s的主要组件有哪些？

+ 谈谈你对于服务网格的理解？

  + 什么是服务网格？

  + 服务网格对比Spring Cloud？

  + 服务网格的实现原理？

## 分布式相关

### 谈谈你对于分布式的理解？

+ 分布式的基本组成是什么？
+ 分布式业务拆分？为什么系统拆分、如何进行系统拆分
+ CAP理论和BASE理论
+ 一致性有哪几个分类？

+ 谈谈对于服务降级的理解？


### 常见分布式问题

+ 用过分布式锁么？
  + 一般的锁是进程内部的线程竞争，分布式锁是不用进程之间资源的竞争
  + 锁的条件：排他性、高可用、可重入性、设置过期时间避免死锁、非阻塞性（获取锁失败，线程不应该阻塞在哪里）
  + 常见实现方式：redis、zk

### 谈谈对于限流的理解？

+ 为什么限流：正常来说，每个系统都有自己能够处理请求的一个瓶颈，限流就是为了保证请求系统的流量不会超过系统的正常承载

### 谈谈你对于设计模式的理解？

+ 什么是设计模式？
+ 为什么使用设计模式？
+ 都用到过哪些设计模式？
+ 设计模式一定就好么？ 针对轻量对象，new更快，如果构造方法相对复杂，可以使用克隆模式

+ 单例模式

  1. 双重锁为什么有两次检查
  2. 为什么使用volitale修饰
     1. new 不是原子性的，它会分为三天指令去执行：为对象分配内存、初始化对象、把实例对象赋值给instance
     2. 多线程情况下，由于指令重排，可能会将一个不完整的对象分配给其他线程
     3. volitale 则避免了指令重排

### 分布式环境下实现单例模式？

+ 可以采用序列化+外部存储+分布式锁的方式
+ 可以分为两部分，先判断这个对象是否存在、是否被使用
+ 如果不存在就新建，如果被使用就等待上一个进行释放当前对象
+ 当前进程拿到对象后，先反序列化成为对象，用完后再序列化将对象保存到外部存储，然后再删除本地内存中的对象

### 谈谈你对于CI\CD的理解？

## 系统设计

### 谈谈你对于高并发的理解？

+ 什么是高并发？

  流量比较高，同时会持续一段时间，这段时间，服务应该要保证稳定运行，同时不因为流量的增加，而导致服务的处理速度产生太大的变化

+ 如何实现高并发？

  + 系统拆分，增加系统的吞吐量
  + 针对性能瓶颈的部分，增加机器节点、设计缓存（适合读多写少的场景）
  + 提升单个接口的处理速度
  + 服务降级，关闭不需要的服务，集中资源
  + 分库分表，提升数据库的吞吐量，降低数据库的IO僻静
  + 读写分离：适合读多写少的场景
  + ES 搜索：针对一些全文搜索的业务，完全可以脱离数据库去做

+ 高并发需要注意什么？

  + 前端限流
  + 增加消息中间件，避免太高的流量造成服务雪崩，（对于高并发的写场景，也能够增加保护的作用）

+ 高并发的常见处理方式？

  + 找到影响我们现在系统的瓶颈，然后去处理，将大问题拆解，然后分而治之，将流量进行分解
  + 预估系统能够承受的最大流量，做好系统的限流措施（过高的流量可能不会让系统崩掉，但是也会让系统的整体性能降低很多）
  + 扩容，增加机器的方式（可以采用多机房的处理方式），dns动态分流
  + cnd缓存
  + 多级缓存设计
  + 系统弹性扩容，机器动态增加
  + 双十一这种，可以采用服务降级，将一些无关的服务停掉，将更多的资源集中到核心服务当中

+ 谈一下你自己的分布式任务调度项目？

  + 设计产品的原因：公司想提升自研实力，正好当时接了一个定时清理系统，所以我们决定开始自研一个分布式任务调度系统
  + 技术架构：Spring Boot、Quartz、OkHttp3、Mysql
  + 架构组成：
    + 调度框架的Leader：负责集群监控、任务分发、任务容错
    + 调度的Follower：负责任务的执行、负载均衡
    + worker：任务的真正执行者
  + 工作流程：定时服务启动时想调度系统注册接口信息，调度系统将注册的信息保存到数据库当中，然后用户可以更具调度系统提供的Api对定时任务进行操作：启动、停止、删除
  + 调度系统的特点有：
    + 高可用：服务之间可以采用集群的方式启动，集群中会有个Leader服务，负责follower节点的状态监控、任务分发，当Leader节点奔溃，其他follower节点会进入选举模式，实现原理通过数据库实现分布式锁，获得锁的服务自动成为Leader，然后向集群中的节点广播这个信息，为了保证锁不会过去，其他follower节点会定时检查获得锁的服务是否挂掉
    + 定时任务容错：定时任务运行时会在数据库写入它的运行信息，包含了：调度服务的follower节点、Corn表达式、上一次运行时间、下一次运行时间、任务是否正在运行等，如果Leader服务发现定时任务异常，会对定时任务进行重新执行
    + 高性能：任务调度采用了异步的方式执行，获取得到的日志结果，也会异步写入到数据库当中
    + 负载均衡：支持执行任务的工作节点进行负载均衡：随机、轮训、加权
    + 执行分片任务，调度器可以讲请求参数拆分，然后在工作节点的集群当中执行


### 设计一个系统流程？

1. 先解析这个业务的工作流程
2. 都使用到了哪些技术？
3. 设计数据库？
4. 代码会有哪些功能接口？

### 谈谈你设计的消息队列？

+ 设计产品的原因：在完成分布式调度任务之后，我对自己提出了另一个比较高的要求，目标瞄准了消息队列
+ 技术架构：Spring Boot 、Netty、Protobuf
+ 架构组成
  + 注册中心：自研，负责worker的注册，保存了消息队列的信息：每个队列的配置信息、队列消费的偏移量，工作节点每隔一段时间，会将队列的数据同步给注册中心，注册中心会将数据持久化到文件当中
  + worker：真正的工作节点
  + 文件服务：负责数据的持久化操作
  + 生产者：消息的生产者
  + 消费者：消息的消费者
+ 工作流程
  + 先启动注册中心、然后启动worker和文件服务，worker想注册中心完成注册
  + 生产者与消费者，启动先访问注册中心，注册中心返回可用的worker节点的IP，然后启动Netty客户端，链接消息队列的工作节点
+ 消息队列的特点：
  + 支持多种功能：消费一对一、一对多，ACK模式，通过DelayQueue实现延时队列
  + 数据持久化：如果需要持久化，消息队列启动文件服务，将消息保存在磁盘当中，服务宕机，消息不丢失，同时每个消息都有自己的一个全局唯一ID，记录了消费者消费的偏移量
  + 副本机制：默认集群启动，每个队列的副本数量为2,
  + 注册中心的高可用：Leader宕机，注册中心进入到选举模式，每个注册中心节点都会存在一个Id，优先推举id最小的节点作为Leader，当推举数大于注册中心节点数量的一般是，该节点就是新的Leader。当然，也可以利用数据库，将Leader选举的流程进行简化
  + 当Worker节点挂掉的时候，生产者和消费者会重新链接到注册中心，获取得到可用的worker节点，如果集群中某个队列的副本数量小于配置，注册中心会开启队列数据的同步指令，这个过程采用UDP的方式进行传输
  + 消息队列的高性能：目前来说我写的Mq还有很多可以提升性能的地方
    + 引入堆外内存，实现零拷贝
    + 加入异步写机制
    + 数据持久化，批量写操作

### 谈谈你对于OAuth的理解？

### 面向MQ编程的生产实践有哪些？

### 设计一个统计程序员代码注释量的系统？

+ 详细数据表
+ 统计数据表
+ 历史数据迁移

+ 集群部署形式的服务端与客户端是长连接，当服务端采用波浪形式的方式重启时，会发现有部分服务端的链接会很多，但是有的服务端链接很少，造成一种负载不均衡的现象

  + 其实情况类似于Kafka再平衡机制，当集群内的节点数量发生变化时，可以有一种再平衡机制，将现有客户端平均分配到现有的集群中的工作节点当中。
  + 这个时候可以有一个注册中心，来实现服务的上下线感知功能，然后触发客户端与服务端的重连，对现有的集群服务进行负载均衡

### 红包雨架构设计

**描述：**

1亿红包，3000万人强，红包数量1000万个，TPS预计百万，如何设计

**尝试沟通问题：**

1. 每个红包额度大小是否相等？
2. 每个用户的红包数量是否有限制？

**关注点**

1. **高性能**：保证用户体验
2. **高可靠**：不能超发
3. 高可用

**设备情况**

+ 负载均衡选择
  + Nginx 万级别（不满足），一般能到5万/s
  + LVS 十万级别 80w/s
  + 商业服务器F5，百万级别，可以达到200万/s~800万/s
+ 如果不想用负载均衡方案，可以使用固定机房+DNS的方式，每个机房固定多少红包，每个地区的用户访问自己的地区机房，然后抢红包之后，通过MQ同步到用户的账户中
+ 按照20个机房计算，每机房也要有50万TPS左右的访问量，这个时候可以使用Redis，按照每个8万计算，可以部署8个服务，然后每个Redis实例存储一个拆分好的红包的 id+红包金额的List，抢红包的时候用Lua脚本从List中 pop 一个元素同时记录到另一个List中，记录用户uid+红包ID+红包金额，然后定时任务集群不断从Redis集群中消费这些数据，批量插入MySql数据库，同时使用MQ通知用户账户入账
  + 可以提前生成每一个红包的金额，不进行实施计算
  + 动态限流，减少无效请求
  + 内存队列，避免争抢
  + 转账异步化
+ 同时我们可以使用uid对Mysql进行分库分表
+ 注意点：中间件的高可用、无状态服务的弹性伸缩、压测和限流

### 对接第三方接口需要注意什么？

+ 接口的安全性
+ 接口的稳定性
+ 接口的访问限制（比如费用）


## 系统问题

### CPU突然飙高，系统反应慢怎么排查？

+ 原因可能存在两个

  + CPU频繁上下文切换，系统中通常会有文件IO、网络IO、锁等待、线程阻塞等原因造成CPU上下文切换
  + CPU资源过度消耗：创建了大量线程或者有线程一直占用CPU（死循环）

+ 解决方案：Top命令找到CPU消耗过高的线程

  + 情况1：CPU利用率过高的始终是用一个线程，这个时候可以使用jstack获取线程的Dump日志，然后定位问题代码
  + 情况2： CPU利用率过高的线程ID不断变化，说明线程创建过多，这个时候，需要挑选几个线程ID去查看Dump日志进行排查 ，最终的结果可能是程序正常，只是当访问量突然变大的时候，导致系统的资源不够，CPU的使用率会突然飙高

### 有一个数据一亿的表，如何进行分库分表？

+ 先观察表，找到一个均与分布的字段，这个字段可以作为一个天然的哈希路由的基准，然后还要结合业务， 判断分表是否合理
  + 比如一张表中有用户Id、订单ID、商户ID
  + 然后看看实际的业务场景，看看哪一个字段的查询场景会更多，如果是根据用户ID查询的频率最高，那么就可以根据用户ID进行路由，这样的话，后期统一用户的数据就会落到同一个数据库，避免了多个数据库之间的交互
  + 如果一些数据按照时间维度统计，那么我们还可以按照年、月、日这样的维度来分
+ 旧数据如何迁移？
  + 方案一：停机迁移，可以是一些小的网站，凌晨时间，不对外提供服务，然后使用写好的数据迁移脚本进行数据迁移，不过这个方案的用户体验不会太好，如果迁移失败，可能需要重新迁移
  + 方案二：双写+同步迁移
    + 新的数据同时写入新表和老表，但是查询仍然使用老表，如果使用一段时间后，新表插入数据没有问题，就可以进行数据迁移，最后对数据进行完整性校验
    + 双写的实现：
      + Mybatis的拦截器
      + Canal+MQ通过订阅的方式进行数据同步，可以在开启双写之前记录一下双写的时间点，然后分批的去迁移，最后要避免在业务的高峰期进行数据迁移
+ 最后增加切换数据源的开关，在完成数据迁移之后，切换到新的数据源

### 亿级日志

**规模：**

+ 1600亿条/天-280万条/秒-300TB/天

**方案：**

+ 14年：SDK+Socket+MongoDB

  + 经常IO阻塞

+ 14-15年：ELK：比较小、传统公司可以采用

  + logstash 存在瓶颈，承载不了峰值压力
  + ES鼓掌是影响比较大
    + 故障时：logstash产生大量日志挤压
    + 恢复时：产生泄洪，瞬间打垮ES（IO、CPU压力大）
  + 方向：将采集和存储解耦

+ 16年之后：agent+kafka+flume+es

  + 采集和存储进行了解耦
  + flume相对于logstash更快
  + 新问题：
    + flume基于能存、会比较吃内存，解决方案：加内存
    + kafka假死现象：如果分区出现消息挤压，强制kafka断开链接，重新rebalance

+ 现在架构：Es多集群，对于日志的优先级进行拆分

  + LV1集群：15%小规模、核心应用，高标准、性能强
  + LV2集群：85%大规模，核心应用+高频应用，高保障、性能优
  + LV3集群：X%总量，warm节点，实时性要求低，性能一般
  + 冷热分离：Hot节点使用SSD高配，支持实时数据，Warm节点，存储历史数据

  



## 其他

### 谈谈你工作中常用的文档？

+ UML图有哪些？
+ 常用的技术文档？

### 禁止IP直连？

+ 可以解耦，避免应用程序和服务器ip的强耦合
+ 通过域名配置，可以实现域名与IP的对应，实现ip的动态迁移
+ 所以解决方案可以是内网系统的DNS解析服务

###  Sql约束为什么禁止3表Join？

问题点：

+ Mycat仅支持2表关联操作
+ Mysql超过3表关联时做的不是很好，很多时候会导致预期的执行效果不是很好
+ 后期的数据量增加，会进行分库分表，join过多也会导致后期的代码需要重新进行维护操作

解决方案：

1. 数据量小：使用拆分join查询为最简单的单表查询
2. 反范式查询：增加反范式表，将我们需要的字段提取成为一个新的表，通过冗余数据的方式建立一个反范式表
3. 大数据解决方案-数据集市（ETL）：通过当天的一个定时任务完成对数据的加工，然后获取得到我们需要的数据，所以数据的显示是T+1



### 项目中遇到未预期的风险，如何处理？

+ 报告上级
+ 判断问题能否解决
+ 影响范围